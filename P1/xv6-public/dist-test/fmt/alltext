0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 int             cpuid(void);
0358 void            exit(void);
0359 int             fork(void);
0360 int             growproc(int);
0361 int             kill(int);
0362 struct cpu*     mycpu(void);
0363 struct proc*    myproc();
0364 void            pinit(void);
0365 void            procdump(void);
0366 void            scheduler(void) __attribute__((noreturn));
0367 void            sched(void);
0368 void            setproc(struct proc*);
0369 void            sleep(void*, struct spinlock*);
0370 void            userinit(void);
0371 int             wait(void);
0372 void            wakeup(void*);
0373 void            yield(void);
0374 
0375 
0376 void            swtch(struct context**, struct context*);
0377 
0378 
0379 void            acquire(struct spinlock*);
0380 void            getcallerpcs(void*, uint*);
0381 int             holding(struct spinlock*);
0382 void            initlock(struct spinlock*, char*);
0383 void            release(struct spinlock*);
0384 void            pushcli(void);
0385 void            popcli(void);
0386 
0387 
0388 void            acquiresleep(struct sleeplock*);
0389 void            releasesleep(struct sleeplock*);
0390 int             holdingsleep(struct sleeplock*);
0391 void            initsleeplock(struct sleeplock*, char*);
0392 
0393 
0394 int             memcmp(const void*, const void*, uint);
0395 void*           memmove(void*, const void*, uint);
0396 void*           memset(void*, int, uint);
0397 char*           safestrcpy(char*, const char*, int);
0398 int             strlen(const char*);
0399 int             strncmp(const char*, const char*, uint);
0400 char*           strncpy(char*, const char*, int);
0401 
0402 
0403 int             argint(int, int*);
0404 int             argptr(int, char**, int);
0405 int             argstr(int, char**);
0406 int             fetchint(uint, int*);
0407 int             fetchstr(uint, char**);
0408 void            syscall(void);
0409 
0410 
0411 void            timerinit(void);
0412 
0413 
0414 void            idtinit(void);
0415 extern uint     ticks;
0416 void            tvinit(void);
0417 extern struct spinlock tickslock;
0418 
0419 
0420 void            uartinit(void);
0421 void            uartintr(void);
0422 void            uartputc(int);
0423 
0424 
0425 void            seginit(void);
0426 void            kvmalloc(void);
0427 pde_t*          setupkvm(void);
0428 char*           uva2ka(pde_t*, char*);
0429 int             allocuvm(pde_t*, uint, uint);
0430 int             deallocuvm(pde_t*, uint, uint);
0431 void            freevm(pde_t*);
0432 void            inituvm(pde_t*, char*, uint);
0433 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0434 pde_t*          copyuvm(pde_t*, uint);
0435 void            switchuvm(struct proc*);
0436 void            switchkvm(void);
0437 int             copyout(pde_t*, uint, void*, uint);
0438 void            clearpteu(pde_t *pgdir, char *uva);
0439 
0440 
0441 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_W     0x2       
0667 #define STA_R     0x2       
0668 
0669 
0670 
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_IF           0x00000200      
0705 
0706 
0707 #define CR0_PE          0x00000001      
0708 #define CR0_WP          0x00010000      
0709 #define CR0_PG          0x80000000      
0710 
0711 #define CR4_PSE         0x00000010      
0712 
0713 
0714 #define SEG_KCODE 1  
0715 #define SEG_KDATA 2  
0716 #define SEG_UCODE 3  
0717 #define SEG_UDATA 4  
0718 #define SEG_TSS   5  
0719 
0720 
0721 #define NSEGS     6
0722 
0723 #ifndef __ASSEMBLER__
0724 
0725 struct segdesc {
0726   uint lim_15_0 : 16;  
0727   uint base_15_0 : 16; 
0728   uint base_23_16 : 8; 
0729   uint type : 4;       
0730   uint s : 1;          
0731   uint dpl : 2;        
0732   uint p : 1;          
0733   uint lim_19_16 : 4;  
0734   uint avl : 1;        
0735   uint rsv1 : 1;       
0736   uint db : 1;         
0737   uint g : 1;          
0738   uint base_31_24 : 8; 
0739 };
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0752 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0753   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0754   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0755 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0756 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0757   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0758   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0759 #endif
0760 
0761 #define DPL_USER    0x3     
0762 
0763 
0764 #define STA_X       0x8     
0765 #define STA_W       0x2     
0766 #define STA_R       0x2     
0767 
0768 
0769 #define STS_T32A    0x9     
0770 #define STS_IG32    0xE     
0771 #define STS_TG32    0xF     
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0783 
0784 
0785 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0786 
0787 
0788 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0789 
0790 
0791 #define NPDENTRIES      1024    
0792 #define NPTENTRIES      1024    
0793 #define PGSIZE          4096    
0794 
0795 #define PTXSHIFT        12      
0796 #define PDXSHIFT        22      
0797 
0798 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0799 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0800 
0801 #define PTE_P           0x001   
0802 #define PTE_W           0x002   
0803 #define PTE_U           0x004   
0804 #define PTE_PS          0x080   
0805 
0806 
0807 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0808 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0809 
0810 #ifndef __ASSEMBLER__
0811 typedef uint pte_t;
0812 
0813 
0814 struct taskstate {
0815   uint link;         
0816   uint esp0;         
0817   ushort ss0;        
0818   ushort padding1;
0819   uint *esp1;
0820   ushort ss1;
0821   ushort padding2;
0822   uint *esp2;
0823   ushort ss2;
0824   ushort padding3;
0825   void *cr3;         
0826   uint *eip;         
0827   uint eflags;
0828   uint eax;          
0829   uint ecx;
0830   uint edx;
0831   uint ebx;
0832   uint *esp;
0833   uint *ebp;
0834   uint esi;
0835   uint edi;
0836   ushort es;         
0837   ushort padding4;
0838   ushort cs;
0839   ushort padding5;
0840   ushort ss;
0841   ushort padding6;
0842   ushort ds;
0843   ushort padding7;
0844   ushort fs;
0845   ushort padding8;
0846   ushort gs;
0847   ushort padding9;
0848   ushort ldt;
0849   ushort padding10;
0850   ushort t;          
0851   ushort iomb;       
0852 };
0853 
0854 
0855 struct gatedesc {
0856   uint off_15_0 : 16;   
0857   uint cs : 16;         
0858   uint args : 5;        
0859   uint rsv1 : 3;        
0860   uint type : 4;        
0861   uint s : 1;           
0862   uint dpl : 2;         
0863   uint p : 1;           
0864   uint off_31_16 : 16;  
0865 };
0866 
0867 
0868 
0869 
0870 
0871 
0872 
0873 
0874 
0875 #define SETGATE(gate, istrap, sel, off, d)                \
0876 {                                                         \
0877   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0878   (gate).cs = (sel);                                      \
0879   (gate).args = 0;                                        \
0880   (gate).rsv1 = 0;                                        \
0881   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0882   (gate).s = 0;                                           \
0883   (gate).dpl = (d);                                       \
0884   (gate).p = 1;                                           \
0885   (gate).off_31_16 = (uint)(off) >> 16;                  \
0886 }
0887 
0888 #endif
0889 
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 
0902 #define ELF_MAGIC 0x464C457FU  
0903 
0904 
0905 struct elfhdr {
0906   uint magic;  
0907   uchar elf[12];
0908   ushort type;
0909   ushort machine;
0910   uint version;
0911   uint entry;
0912   uint phoff;
0913   uint shoff;
0914   uint flags;
0915   ushort ehsize;
0916   ushort phentsize;
0917   ushort phnum;
0918   ushort shentsize;
0919   ushort shnum;
0920   ushort shstrndx;
0921 };
0922 
0923 
0924 struct proghdr {
0925   uint type;
0926   uint off;
0927   uint vaddr;
0928   uint paddr;
0929   uint filesz;
0930   uint memsz;
0931   uint flags;
0932   uint align;
0933 };
0934 
0935 
0936 #define ELF_PROG_LOAD           1
0937 
0938 
0939 #define ELF_PROG_FLAG_EXEC      1
0940 #define ELF_PROG_FLAG_WRITE     2
0941 #define ELF_PROG_FLAG_READ      4
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 struct rtcdate {
0951   uint second;
0952   uint minute;
0953   uint hour;
0954   uint day;
0955   uint month;
0956   uint year;
0957 };
0958 
0959 
0960 
0961 
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 
0972 
0973 
0974 
0975 
0976 
0977 
0978 
0979 
0980 
0981 
0982 
0983 
0984 
0985 
0986 
0987 
0988 
0989 
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 
1043 .globl entry
1044 entry:
1045   
1046   movl    %cr4, %eax
1047   orl     $(CR4_PSE), %eax
1048   movl    %eax, %cr4
1049   
1050   movl    $(V2P_WO(entrypgdir)), %eax
1051   movl    %eax, %cr3
1052   
1053   movl    %cr0, %eax
1054   orl     $(CR0_PG|CR0_WP), %eax
1055   movl    %eax, %cr0
1056 
1057   
1058   movl $(stack + KSTACKSIZE), %esp
1059 
1060   
1061   
1062   
1063   
1064   mov $main, %eax
1065   jmp *%eax
1066 
1067 .comm stack, KSTACKSIZE
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 .code32  
1146 start32:
1147   
1148   movw    $(SEG_KDATA<<3), %ax    
1149   movw    %ax, %ds                
1150   movw    %ax, %es                
1151   movw    %ax, %ss                
1152   movw    $0, %ax                 
1153   movw    %ax, %fs                
1154   movw    %ax, %gs                
1155 
1156   
1157   movl    %cr4, %eax
1158   orl     $(CR4_PSE), %eax
1159   movl    %eax, %cr4
1160   
1161   movl    (start-12), %eax
1162   movl    %eax, %cr3
1163   
1164   movl    %cr0, %eax
1165   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1166   movl    %eax, %cr0
1167 
1168   
1169   movl    (start-4), %esp
1170   
1171   call	 *(start-8)
1172 
1173   movw    $0x8a00, %ax
1174   movw    %ax, %dx
1175   outw    %ax, %dx
1176   movw    $0x8ae0, %ax
1177   outw    %ax, %dx
1178 spin:
1179   jmp     spin
1180 
1181 .p2align 2
1182 gdt:
1183   SEG_NULLASM
1184   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1185   SEG_ASM(STA_W, 0, 0xffffffff)
1186 
1187 
1188 gdtdesc:
1189   .word   (gdtdesc - gdt - 1)
1190   .long   gdt
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();     
1223   seginit();       
1224   picinit();       
1225   ioapicinit();    
1226   consoleinit();   
1227   uartinit();      
1228   pinit();         
1229   tvinit();        
1230   binit();         
1231   fileinit();      
1232   ideinit();       
1233   startothers();   
1234   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1235   userinit();      
1236   mpmain();        
1237 }
1238 
1239 
1240 static void
1241 mpenter(void)
1242 {
1243   switchkvm();
1244   seginit();
1245   lapicinit();
1246   mpmain();
1247 }
1248 
1249 
1250 
1251 static void
1252 mpmain(void)
1253 {
1254   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1255   idtinit();       
1256   xchg(&(mycpu()->started), 1); 
1257   scheduler();     
1258 }
1259 
1260 pde_t entrypgdir[];  
1261 
1262 
1263 static void
1264 startothers(void)
1265 {
1266   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1267   uchar *code;
1268   struct cpu *c;
1269   char *stack;
1270 
1271   
1272   
1273   
1274   code = P2V(0x7000);
1275   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1276 
1277   for(c = cpus; c < cpus+ncpu; c++){
1278     if(c == mycpu())  
1279       continue;
1280 
1281     
1282     
1283     
1284     stack = kalloc();
1285     *(void**)(code-4) = stack + KSTACKSIZE;
1286     *(void(**)(void))(code-8) = mpenter;
1287     *(int**)(code-12) = (void *) V2P(entrypgdir);
1288 
1289     lapicstartap(c->apicid, V2P(code));
1290 
1291     
1292     while(c->started == 0)
1293       ;
1294   }
1295 }
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 __attribute__((__aligned__(PGSIZE)))
1306 pde_t entrypgdir[NPDENTRIES] = {
1307   
1308   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1309   
1310   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1311 };
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 struct spinlock {
1352   uint locked;       
1353 
1354   
1355   char *name;        
1356   struct cpu *cpu;   
1357   uint pcs[10];      
1358                      
1359 };
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 #include "types.h"
1403 #include "defs.h"
1404 #include "param.h"
1405 #include "x86.h"
1406 #include "memlayout.h"
1407 #include "mmu.h"
1408 #include "proc.h"
1409 #include "spinlock.h"
1410 
1411 void
1412 initlock(struct spinlock *lk, char *name)
1413 {
1414   lk->name = name;
1415   lk->locked = 0;
1416   lk->cpu = 0;
1417 }
1418 
1419 
1420 
1421 
1422 
1423 void
1424 acquire(struct spinlock *lk)
1425 {
1426   pushcli(); 
1427   if(holding(lk))
1428     panic("acquire");
1429 
1430   
1431   while(xchg(&lk->locked, 1) != 0)
1432     ;
1433 
1434   
1435   
1436   
1437   __sync_synchronize();
1438 
1439   
1440   lk->cpu = mycpu();
1441   getcallerpcs(&lk, lk->pcs);
1442 }
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 void
1452 release(struct spinlock *lk)
1453 {
1454   if(!holding(lk))
1455     panic("release");
1456 
1457   lk->pcs[0] = 0;
1458   lk->cpu = 0;
1459 
1460   
1461   
1462   
1463   
1464   
1465   __sync_synchronize();
1466 
1467   
1468   
1469   
1470   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1471 
1472   popcli();
1473 }
1474 
1475 
1476 void
1477 getcallerpcs(void *v, uint pcs[])
1478 {
1479   uint *ebp;
1480   int i;
1481 
1482   ebp = (uint*)v - 2;
1483   for(i = 0; i < 10; i++){
1484     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1485       break;
1486     pcs[i] = ebp[1];     
1487     ebp = (uint*)ebp[0]; 
1488   }
1489   for(; i < 10; i++)
1490     pcs[i] = 0;
1491 }
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 int
1502 holding(struct spinlock *lock)
1503 {
1504   int r;
1505   pushcli();
1506   r = lock->locked && lock->cpu == mycpu();
1507   popcli();
1508   return r;
1509 }
1510 
1511 
1512 
1513 
1514 
1515 
1516 void
1517 pushcli(void)
1518 {
1519   int eflags;
1520 
1521   eflags = readeflags();
1522   cli();
1523   if(mycpu()->ncli == 0)
1524     mycpu()->intena = eflags & FL_IF;
1525   mycpu()->ncli += 1;
1526 }
1527 
1528 void
1529 popcli(void)
1530 {
1531   if(readeflags()&FL_IF)
1532     panic("popcli - interruptible");
1533   if(--mycpu()->ncli < 0)
1534     panic("popcli");
1535   if(mycpu()->ncli == 0 && mycpu()->intena)
1536     sti();
1537 }
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 #include "param.h"
1551 #include "types.h"
1552 #include "defs.h"
1553 #include "x86.h"
1554 #include "memlayout.h"
1555 #include "mmu.h"
1556 #include "proc.h"
1557 #include "elf.h"
1558 
1559 extern char data[];  
1560 pde_t *kpgdir;  
1561 
1562 
1563 
1564 void
1565 seginit(void)
1566 {
1567   struct cpu *c;
1568 
1569   
1570   
1571   
1572   
1573   c = &cpus[cpuid()];
1574   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1575   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1576   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1577   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1578   lgdt(c->gdt, sizeof(c->gdt));
1579 }
1580 
1581 
1582 
1583 
1584 static pte_t *
1585 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1586 {
1587   pde_t *pde;
1588   pte_t *pgtab;
1589 
1590   pde = &pgdir[PDX(va)];
1591   if(*pde & PTE_P){
1592     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1593   } else {
1594     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1595       return 0;
1596     
1597     memset(pgtab, 0, PGSIZE);
1598     
1599     
1600     
1601     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1602   }
1603   return &pgtab[PTX(va)];
1604 }
1605 
1606 
1607 
1608 
1609 static int
1610 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1611 {
1612   char *a, *last;
1613   pte_t *pte;
1614 
1615   a = (char*)PGROUNDDOWN((uint)va);
1616   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1617   for(;;){
1618     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1619       return -1;
1620     if(*pte & PTE_P)
1621       panic("remap");
1622     *pte = pa | perm | PTE_P;
1623     if(a == last)
1624       break;
1625     a += PGSIZE;
1626     pa += PGSIZE;
1627   }
1628   return 0;
1629 }
1630 
1631 
1632 
1633 
1634 
1635 
1636 
1637 
1638 
1639 
1640 
1641 
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 
1652 
1653 
1654 static struct kmap {
1655   void *virt;
1656   uint phys_start;
1657   uint phys_end;
1658   int perm;
1659 } kmap[] = {
1660  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1661  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1662  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1663  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1664 };
1665 
1666 
1667 pde_t*
1668 setupkvm(void)
1669 {
1670   pde_t *pgdir;
1671   struct kmap *k;
1672 
1673   if((pgdir = (pde_t*)kalloc()) == 0)
1674     return 0;
1675   memset(pgdir, 0, PGSIZE);
1676   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1677     panic("PHYSTOP too high");
1678   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1679     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1680                 (uint)k->phys_start, k->perm) < 0) {
1681       freevm(pgdir);
1682       return 0;
1683     }
1684   return pgdir;
1685 }
1686 
1687 
1688 
1689 void
1690 kvmalloc(void)
1691 {
1692   kpgdir = setupkvm();
1693   switchkvm();
1694 }
1695 
1696 
1697 
1698 
1699 
1700 
1701 
1702 void
1703 switchkvm(void)
1704 {
1705   lcr3(V2P(kpgdir));   
1706 }
1707 
1708 
1709 void
1710 switchuvm(struct proc *p)
1711 {
1712   if(p == 0)
1713     panic("switchuvm: no process");
1714   if(p->kstack == 0)
1715     panic("switchuvm: no kstack");
1716   if(p->pgdir == 0)
1717     panic("switchuvm: no pgdir");
1718 
1719   pushcli();
1720   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1721                                 sizeof(mycpu()->ts)-1, 0);
1722   mycpu()->gdt[SEG_TSS].s = 0;
1723   mycpu()->ts.ss0 = SEG_KDATA << 3;
1724   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1725   
1726   
1727   mycpu()->ts.iomb = (ushort) 0xFFFF;
1728   ltr(SEG_TSS << 3);
1729   lcr3(V2P(p->pgdir));  
1730   popcli();
1731 }
1732 
1733 
1734 
1735 void
1736 inituvm(pde_t *pgdir, char *init, uint sz)
1737 {
1738   char *mem;
1739 
1740   if(sz >= PGSIZE)
1741     panic("inituvm: more than a page");
1742   mem = kalloc();
1743   memset(mem, 0, PGSIZE);
1744   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1745   memmove(mem, init, sz);
1746 }
1747 
1748 
1749 
1750 
1751 
1752 int
1753 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1754 {
1755   uint i, pa, n;
1756   pte_t *pte;
1757 
1758   if((uint) addr % PGSIZE != 0)
1759     panic("loaduvm: addr must be page aligned");
1760   for(i = 0; i < sz; i += PGSIZE){
1761     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1762       panic("loaduvm: address should exist");
1763     pa = PTE_ADDR(*pte);
1764     if(sz - i < PGSIZE)
1765       n = sz - i;
1766     else
1767       n = PGSIZE;
1768     if(readi(ip, P2V(pa), offset+i, n) != n)
1769       return -1;
1770   }
1771   return 0;
1772 }
1773 
1774 
1775 
1776 int
1777 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1778 {
1779   char *mem;
1780   uint a;
1781 
1782   if(newsz >= KERNBASE)
1783     return 0;
1784   if(newsz < oldsz)
1785     return oldsz;
1786 
1787   a = PGROUNDUP(oldsz);
1788   for(; a < newsz; a += PGSIZE){
1789     mem = kalloc();
1790     if(mem == 0){
1791       cprintf("allocuvm out of memory\n");
1792       deallocuvm(pgdir, newsz, oldsz);
1793       return 0;
1794     }
1795     memset(mem, 0, PGSIZE);
1796     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1797       cprintf("allocuvm out of memory (2)\n");
1798       deallocuvm(pgdir, newsz, oldsz);
1799       kfree(mem);
1800       return 0;
1801     }
1802   }
1803   return newsz;
1804 }
1805 
1806 
1807 
1808 
1809 
1810 int
1811 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1812 {
1813   pte_t *pte;
1814   uint a, pa;
1815 
1816   if(newsz >= oldsz)
1817     return oldsz;
1818 
1819   a = PGROUNDUP(newsz);
1820   for(; a  < oldsz; a += PGSIZE){
1821     pte = walkpgdir(pgdir, (char*)a, 0);
1822     if(!pte)
1823       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
1824     else if((*pte & PTE_P) != 0){
1825       pa = PTE_ADDR(*pte);
1826       if(pa == 0)
1827         panic("kfree");
1828       char *v = P2V(pa);
1829       kfree(v);
1830       *pte = 0;
1831     }
1832   }
1833   return newsz;
1834 }
1835 
1836 
1837 
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 void
1853 freevm(pde_t *pgdir)
1854 {
1855   uint i;
1856 
1857   if(pgdir == 0)
1858     panic("freevm: no pgdir");
1859   deallocuvm(pgdir, KERNBASE, 0);
1860   for(i = 0; i < NPDENTRIES; i++){
1861     if(pgdir[i] & PTE_P){
1862       char * v = P2V(PTE_ADDR(pgdir[i]));
1863       kfree(v);
1864     }
1865   }
1866   kfree((char*)pgdir);
1867 }
1868 
1869 
1870 
1871 void
1872 clearpteu(pde_t *pgdir, char *uva)
1873 {
1874   pte_t *pte;
1875 
1876   pte = walkpgdir(pgdir, uva, 0);
1877   if(pte == 0)
1878     panic("clearpteu");
1879   *pte &= ~PTE_U;
1880 }
1881 
1882 
1883 
1884 pde_t*
1885 copyuvm(pde_t *pgdir, uint sz)
1886 {
1887   pde_t *d;
1888   pte_t *pte;
1889   uint pa, i, flags;
1890   char *mem;
1891 
1892   if((d = setupkvm()) == 0)
1893     return 0;
1894   for(i = 0; i < sz; i += PGSIZE){
1895     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1896       panic("copyuvm: pte should exist");
1897     if(!(*pte & PTE_P))
1898       panic("copyuvm: page not present");
1899     pa = PTE_ADDR(*pte);
1900     flags = PTE_FLAGS(*pte);
1901     if((mem = kalloc()) == 0)
1902       goto bad;
1903     memmove(mem, (char*)P2V(pa), PGSIZE);
1904     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
1905       kfree(mem);
1906       goto bad;
1907     }
1908   }
1909   return d;
1910 
1911 bad:
1912   freevm(d);
1913   return 0;
1914 }
1915 
1916 
1917 char*
1918 uva2ka(pde_t *pgdir, char *uva)
1919 {
1920   pte_t *pte;
1921 
1922   pte = walkpgdir(pgdir, uva, 0);
1923   if((*pte & PTE_P) == 0)
1924     return 0;
1925   if((*pte & PTE_U) == 0)
1926     return 0;
1927   return (char*)P2V(PTE_ADDR(*pte));
1928 }
1929 
1930 
1931 
1932 
1933 int
1934 copyout(pde_t *pgdir, uint va, void *p, uint len)
1935 {
1936   char *buf, *pa0;
1937   uint n, va0;
1938 
1939   buf = (char*)p;
1940   while(len > 0){
1941     va0 = (uint)PGROUNDDOWN(va);
1942     pa0 = uva2ka(pgdir, (char*)va0);
1943     if(pa0 == 0)
1944       return -1;
1945     n = PGSIZE - (va - va0);
1946     if(n > len)
1947       n = len;
1948     memmove(pa0 + (va - va0), buf, n);
1949     len -= n;
1950     buf += n;
1951     va = va0 + PGSIZE;
1952   }
1953   return 0;
1954 }
1955 
1956 
1957 
1958 
1959 
1960 
1961 
1962 
1963 
1964 
1965 
1966 
1967 
1968 
1969 
1970 
1971 
1972 
1973 
1974 
1975 
1976 
1977 
1978 
1979 
1980 
1981 
1982 
1983 
1984 
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 struct cpu {
2002   uchar apicid;                
2003   struct context *scheduler;   
2004   struct taskstate ts;         
2005   struct segdesc gdt[NSEGS];   
2006   volatile uint started;       
2007   int ncli;                    
2008   int intena;                  
2009   struct proc *proc;           
2010 };
2011 
2012 extern struct cpu cpus[NCPU];
2013 extern int ncpu;
2014 
2015 
2016 
2017 
2018 
2019 
2020 
2021 
2022 
2023 
2024 
2025 struct context {
2026   uint edi;
2027   uint esi;
2028   uint ebx;
2029   uint ebp;
2030   uint eip;
2031 };
2032 
2033 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2034 
2035 
2036 struct proc {
2037   uint sz;                     
2038   pde_t* pgdir;                
2039   char *kstack;                
2040   enum procstate state;        
2041   int pid;                     
2042   struct proc *parent;         
2043   struct trapframe *tf;        
2044   struct context *context;     
2045   void *chan;                  
2046   int killed;                  
2047   struct file *ofile[NOFILE];  
2048   struct inode *cwd;           
2049   char name[16];               
2050 };
2051 
2052 
2053 
2054 
2055 
2056 
2057 
2058 
2059 
2060 
2061 
2062 
2063 
2064 
2065 
2066 
2067 
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 #include "types.h"
2101 #include "defs.h"
2102 #include "param.h"
2103 #include "memlayout.h"
2104 #include "mmu.h"
2105 #include "x86.h"
2106 #include "proc.h"
2107 #include "spinlock.h"
2108 
2109 struct {
2110   struct spinlock lock;
2111   struct proc proc[NPROC];
2112 } ptable;
2113 
2114 static struct proc *initproc;
2115 
2116 int nextpid = 1;
2117 extern void forkret(void);
2118 extern void trapret(void);
2119 
2120 static void wakeup1(void *chan);
2121 
2122 void
2123 pinit(void)
2124 {
2125   initlock(&ptable.lock, "ptable");
2126 }
2127 
2128 
2129 int
2130 cpuid() {
2131   return mycpu()-cpus;
2132 }
2133 
2134 
2135 
2136 struct cpu*
2137 mycpu(void)
2138 {
2139   int apicid, i;
2140 
2141   if(readeflags()&FL_IF)
2142     panic("mycpu called with interrupts enabled\n");
2143 
2144   apicid = lapicid();
2145   
2146   
2147   for (i = 0; i < ncpu; ++i) {
2148     if (cpus[i].apicid == apicid)
2149       return &cpus[i];
2150   }
2151   panic("unknown apicid\n");
2152 }
2153 
2154 
2155 
2156 struct proc*
2157 myproc(void) {
2158   struct cpu *c;
2159   struct proc *p;
2160   pushcli();
2161   c = mycpu();
2162   p = c->proc;
2163   popcli();
2164   return p;
2165 }
2166 
2167 
2168 
2169 
2170 
2171 static struct proc*
2172 allocproc(void)
2173 {
2174   struct proc *p;
2175   char *sp;
2176 
2177   acquire(&ptable.lock);
2178 
2179   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2180     if(p->state == UNUSED)
2181       goto found;
2182 
2183   release(&ptable.lock);
2184   return 0;
2185 
2186 found:
2187   p->state = EMBRYO;
2188   p->pid = nextpid++;
2189 
2190   release(&ptable.lock);
2191 
2192   
2193   if((p->kstack = kalloc()) == 0){
2194     p->state = UNUSED;
2195     return 0;
2196   }
2197   sp = p->kstack + KSTACKSIZE;
2198 
2199 
2200   
2201   sp -= sizeof *p->tf;
2202   p->tf = (struct trapframe*)sp;
2203 
2204   
2205   
2206   sp -= 4;
2207   *(uint*)sp = (uint)trapret;
2208 
2209   sp -= sizeof *p->context;
2210   p->context = (struct context*)sp;
2211   memset(p->context, 0, sizeof *p->context);
2212   p->context->eip = (uint)forkret;
2213 
2214   return p;
2215 }
2216 
2217 
2218 void
2219 userinit(void)
2220 {
2221   struct proc *p;
2222   extern char _binary_initcode_start[], _binary_initcode_size[];
2223 
2224   p = allocproc();
2225 
2226   initproc = p;
2227   if((p->pgdir = setupkvm()) == 0)
2228     panic("userinit: out of memory?");
2229   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2230   p->sz = PGSIZE;
2231   memset(p->tf, 0, sizeof(*p->tf));
2232   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2233   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2234   p->tf->es = p->tf->ds;
2235   p->tf->ss = p->tf->ds;
2236   p->tf->eflags = FL_IF;
2237   p->tf->esp = PGSIZE;
2238   p->tf->eip = 0;  
2239 
2240   safestrcpy(p->name, "initcode", sizeof(p->name));
2241   p->cwd = namei("/");
2242 
2243   
2244   
2245   
2246   
2247   acquire(&ptable.lock);
2248 
2249   p->state = RUNNABLE;
2250   release(&ptable.lock);
2251 }
2252 
2253 
2254 
2255 int
2256 growproc(int n)
2257 {
2258   uint sz;
2259   struct proc *curproc = myproc();
2260 
2261   sz = curproc->sz;
2262   if(n > 0){
2263     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2264       return -1;
2265   } else if(n < 0){
2266     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2267       return -1;
2268   }
2269   curproc->sz = sz;
2270   switchuvm(curproc);
2271   return 0;
2272 }
2273 
2274 
2275 
2276 
2277 int
2278 fork(void)
2279 {
2280   int i, pid;
2281   struct proc *np;
2282   struct proc *curproc = myproc();
2283 
2284   
2285   if((np = allocproc()) == 0){
2286     return -1;
2287   }
2288 
2289   
2290   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2291     kfree(np->kstack);
2292     np->kstack = 0;
2293     np->state = UNUSED;
2294     return -1;
2295   }
2296   np->sz = curproc->sz;
2297   np->parent = curproc;
2298   *np->tf = *curproc->tf;
2299 
2300   
2301   np->tf->eax = 0;
2302 
2303   for(i = 0; i < NOFILE; i++)
2304     if(curproc->ofile[i])
2305       np->ofile[i] = filedup(curproc->ofile[i]);
2306   np->cwd = idup(curproc->cwd);
2307 
2308   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2309 
2310   pid = np->pid;
2311 
2312   acquire(&ptable.lock);
2313 
2314   np->state = RUNNABLE;
2315 
2316   release(&ptable.lock);
2317 
2318   return pid;
2319 }
2320 
2321 
2322 
2323 
2324 void
2325 exit(void)
2326 {
2327   struct proc *curproc = myproc();
2328   struct proc *p;
2329   int fd;
2330 
2331   if(curproc == initproc)
2332     panic("init exiting");
2333 
2334   
2335   for(fd = 0; fd < NOFILE; fd++){
2336     if(curproc->ofile[fd]){
2337       fileclose(curproc->ofile[fd]);
2338       curproc->ofile[fd] = 0;
2339     }
2340   }
2341 
2342   begin_op();
2343   iput(curproc->cwd);
2344   end_op();
2345   curproc->cwd = 0;
2346 
2347   acquire(&ptable.lock);
2348 
2349 
2350   
2351   wakeup1(curproc->parent);
2352 
2353   
2354   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2355     if(p->parent == curproc){
2356       p->parent = initproc;
2357       if(p->state == ZOMBIE)
2358         wakeup1(initproc);
2359     }
2360   }
2361 
2362   
2363   curproc->state = ZOMBIE;
2364   sched();
2365   panic("zombie exit");
2366 }
2367 
2368 
2369 
2370 int
2371 wait(void)
2372 {
2373   struct proc *p;
2374   int havekids, pid;
2375   struct proc *curproc = myproc();
2376 
2377   acquire(&ptable.lock);
2378   for(;;){
2379     
2380     havekids = 0;
2381     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2382       if(p->parent != curproc)
2383         continue;
2384       havekids = 1;
2385       if(p->state == ZOMBIE){
2386         
2387         pid = p->pid;
2388         kfree(p->kstack);
2389         p->kstack = 0;
2390         freevm(p->pgdir);
2391         p->pid = 0;
2392         p->parent = 0;
2393         p->name[0] = 0;
2394         p->killed = 0;
2395         p->state = UNUSED;
2396         release(&ptable.lock);
2397         return pid;
2398       }
2399     }
2400     
2401     if(!havekids || curproc->killed){
2402       release(&ptable.lock);
2403       return -1;
2404     }
2405 
2406     
2407     sleep(curproc, &ptable.lock);  
2408   }
2409 }
2410 
2411 
2412 
2413 
2414 
2415 
2416 
2417 
2418 void
2419 scheduler(void)
2420 {
2421   struct proc *p;
2422   struct cpu *c = mycpu();
2423   c->proc = 0;
2424 
2425   for(;;){
2426     
2427     sti();
2428 
2429     
2430     acquire(&ptable.lock);
2431     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2432       if(p->state != RUNNABLE)
2433         continue;
2434 
2435       
2436       
2437       
2438       c->proc = p;
2439       switchuvm(p);
2440       p->state = RUNNING;
2441 
2442       swtch(&(c->scheduler), p->context);
2443       switchkvm();
2444 
2445       
2446       
2447       c->proc = 0;
2448     }
2449     release(&ptable.lock);
2450   }
2451 }
2452 
2453 
2454 
2455 
2456 
2457 
2458 
2459 
2460 void
2461 sched(void)
2462 {
2463   int intena;
2464   struct proc *p = myproc();
2465 
2466   if(!holding(&ptable.lock))
2467     panic("sched ptable.lock");
2468   if(mycpu()->ncli != 1)
2469     panic("sched locks");
2470   if(p->state == RUNNING)
2471     panic("sched running");
2472   if(readeflags()&FL_IF)
2473     panic("sched interruptible");
2474   intena = mycpu()->intena;
2475   swtch(&p->context, mycpu()->scheduler);
2476   mycpu()->intena = intena;
2477 }
2478 
2479 
2480 void
2481 yield(void)
2482 {
2483   acquire(&ptable.lock);  
2484   myproc()->state = RUNNABLE;
2485   sched();
2486   release(&ptable.lock);
2487 }
2488 
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 void
2503 forkret(void)
2504 {
2505   static int first = 1;
2506   
2507   release(&ptable.lock);
2508 
2509   if (first) {
2510     
2511     
2512     
2513     first = 0;
2514     iinit(ROOTDEV);
2515     initlog(ROOTDEV);
2516   }
2517 
2518   
2519 }
2520 
2521 
2522 
2523 void
2524 sleep(void *chan, struct spinlock *lk)
2525 {
2526   struct proc *p = myproc();
2527 
2528   if(p == 0)
2529     panic("sleep");
2530 
2531   if(lk == 0)
2532     panic("sleep without lk");
2533 
2534   
2535   
2536   
2537   
2538   
2539   
2540   if(lk != &ptable.lock){  
2541     acquire(&ptable.lock);  
2542     release(lk);
2543   }
2544   
2545   p->chan = chan;
2546   p->state = SLEEPING;
2547 
2548   sched();
2549 
2550   
2551   p->chan = 0;
2552 
2553   
2554   if(lk != &ptable.lock){  
2555     release(&ptable.lock);
2556     acquire(lk);
2557   }
2558 }
2559 
2560 
2561 
2562 static void
2563 wakeup1(void *chan)
2564 {
2565   struct proc *p;
2566 
2567   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2568     if(p->state == SLEEPING && p->chan == chan)
2569       p->state = RUNNABLE;
2570 }
2571 
2572 
2573 void
2574 wakeup(void *chan)
2575 {
2576   acquire(&ptable.lock);
2577   wakeup1(chan);
2578   release(&ptable.lock);
2579 }
2580 
2581 
2582 
2583 
2584 int
2585 kill(int pid)
2586 {
2587   struct proc *p;
2588 
2589   acquire(&ptable.lock);
2590   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2591     if(p->pid == pid){
2592       p->killed = 1;
2593       
2594       if(p->state == SLEEPING)
2595         p->state = RUNNABLE;
2596       release(&ptable.lock);
2597       return 0;
2598     }
2599   }
2600   release(&ptable.lock);
2601   return -1;
2602 }
2603 
2604 
2605 
2606 
2607 void
2608 procdump(void)
2609 {
2610   static char *states[] = {
2611   [UNUSED]    "unused",
2612   [EMBRYO]    "embryo",
2613   [SLEEPING]  "sleep ",
2614   [RUNNABLE]  "runble",
2615   [RUNNING]   "run   ",
2616   [ZOMBIE]    "zombie"
2617   };
2618   int i;
2619   struct proc *p;
2620   char *state;
2621   uint pc[10];
2622 
2623   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2624     if(p->state == UNUSED)
2625       continue;
2626     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2627       state = states[p->state];
2628     else
2629       state = "???";
2630     cprintf("%d %s %s", p->pid, state, p->name);
2631     if(p->state == SLEEPING){
2632       getcallerpcs((uint*)p->context->ebp+2, pc);
2633       for(i=0; i<10 && pc[i] != 0; i++)
2634         cprintf(" %p", pc[i]);
2635     }
2636     cprintf("\n");
2637   }
2638 }
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 
2655 
2656 
2657 
2658 .globl swtch
2659 swtch:
2660   movl 4(%esp), %eax
2661   movl 8(%esp), %edx
2662 
2663   
2664   pushl %ebp
2665   pushl %ebx
2666   pushl %esi
2667   pushl %edi
2668 
2669   
2670   movl %esp, (%eax)
2671   movl %edx, %esp
2672 
2673   
2674   popl %edi
2675   popl %esi
2676   popl %ebx
2677   popl %ebp
2678   ret
2679 
2680 
2681 
2682 
2683 
2684 
2685 
2686 
2687 
2688 
2689 
2690 
2691 
2692 
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 
2701 
2702 
2703 
2704 #include "types.h"
2705 #include "defs.h"
2706 #include "param.h"
2707 #include "memlayout.h"
2708 #include "mmu.h"
2709 #include "spinlock.h"
2710 
2711 void freerange(void *vstart, void *vend);
2712 extern char end[]; 
2713                    
2714 
2715 struct run {
2716   struct run *next;
2717 };
2718 
2719 struct {
2720   struct spinlock lock;
2721   int use_lock;
2722   struct run *freelist;
2723 } kmem;
2724 
2725 
2726 
2727 
2728 
2729 
2730 void
2731 kinit1(void *vstart, void *vend)
2732 {
2733   initlock(&kmem.lock, "kmem");
2734   kmem.use_lock = 0;
2735   freerange(vstart, vend);
2736 }
2737 
2738 void
2739 kinit2(void *vstart, void *vend)
2740 {
2741   freerange(vstart, vend);
2742   kmem.use_lock = 1;
2743 }
2744 
2745 
2746 
2747 
2748 
2749 
2750 void
2751 freerange(void *vstart, void *vend)
2752 {
2753   char *p;
2754   p = (char*)PGROUNDUP((uint)vstart);
2755   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
2756     kfree(p);
2757 }
2758 
2759 
2760 
2761 
2762 void
2763 kfree(char *v)
2764 {
2765   struct run *r;
2766 
2767   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
2768     panic("kfree");
2769 
2770   
2771   memset(v, 1, PGSIZE);
2772 
2773   if(kmem.use_lock)
2774     acquire(&kmem.lock);
2775   r = (struct run*)v;
2776   r->next = kmem.freelist;
2777   kmem.freelist = r;
2778   if(kmem.use_lock)
2779     release(&kmem.lock);
2780 }
2781 
2782 
2783 
2784 
2785 char*
2786 kalloc(void)
2787 {
2788   struct run *r;
2789 
2790   if(kmem.use_lock)
2791     acquire(&kmem.lock);
2792   r = kmem.freelist;
2793   if(r)
2794     kmem.freelist = r->next;
2795   if(kmem.use_lock)
2796     release(&kmem.lock);
2797   return (char*)r;
2798 }
2799 
2800 
2801 
2802 
2803 #define T_DIVIDE         0      
2804 #define T_DEBUG          1      
2805 #define T_NMI            2      
2806 #define T_BRKPT          3      
2807 #define T_OFLOW          4      
2808 #define T_BOUND          5      
2809 #define T_ILLOP          6      
2810 #define T_DEVICE         7      
2811 #define T_DBLFLT         8      
2812 
2813 #define T_TSS           10      
2814 #define T_SEGNP         11      
2815 #define T_STACK         12      
2816 #define T_GPFLT         13      
2817 #define T_PGFLT         14      
2818 
2819 #define T_FPERR         16      
2820 #define T_ALIGN         17      
2821 #define T_MCHK          18      
2822 #define T_SIMDERR       19      
2823 
2824 
2825 
2826 #define T_SYSCALL       64      
2827 #define T_DEFAULT      500      
2828 
2829 #define T_IRQ0          32      
2830 
2831 #define IRQ_TIMER        0
2832 #define IRQ_KBD          1
2833 #define IRQ_COM1         4
2834 #define IRQ_IDE         14
2835 #define IRQ_ERROR       19
2836 #define IRQ_SPURIOUS    31
2837 
2838 
2839 
2840 
2841 
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 #!/usr/bin/perl -w
2851 
2852 # Generate vectors.S, the trap/interrupt entry points.
2853 # There has to be one entry point per interrupt number
2854 # since otherwise there's no way for trap() to discover
2855 # the interrupt number.
2856 
2857 print "# generated by vectors.pl - do not edit\n";
2858 print "# handlers\n";
2859 print ".globl alltraps\n";
2860 for(my $i = 0; $i < 256; $i++){
2861     print ".globl vector$i\n";
2862     print "vector$i:\n";
2863     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
2864         print "  pushl \$0\n";
2865     }
2866     print "  pushl \$$i\n";
2867     print "  jmp alltraps\n";
2868 }
2869 
2870 print "\n# vector table\n";
2871 print ".data\n";
2872 print ".globl vectors\n";
2873 print "vectors:\n";
2874 for(my $i = 0; $i < 256; $i++){
2875     print "  .long vector$i\n";
2876 }
2877 
2878 # sample output:
2879 #   # handlers
2880 #   .globl alltraps
2881 #   .globl vector0
2882 #   vector0:
2883 #     pushl $0
2884 #     pushl $0
2885 #     jmp alltraps
2886 #   ...
2887 #
2888 #   # vector table
2889 #   .data
2890 #   .globl vectors
2891 #   vectors:
2892 #     .long vector0
2893 #     .long vector1
2894 #     .long vector2
2895 #   ...
2896 
2897 
2898 
2899 
2900 
2901 
2902   
2903 .globl alltraps
2904 alltraps:
2905   
2906   pushl %ds
2907   pushl %es
2908   pushl %fs
2909   pushl %gs
2910   pushal
2911 
2912   
2913   movw $(SEG_KDATA<<3), %ax
2914   movw %ax, %ds
2915   movw %ax, %es
2916 
2917   
2918   pushl %esp
2919   call trap
2920   addl $4, %esp
2921 
2922   
2923 .globl trapret
2924 trapret:
2925   popal
2926   popl %gs
2927   popl %fs
2928   popl %es
2929   popl %ds
2930   addl $0x8, %esp  
2931   iret
2932 
2933 
2934 
2935 
2936 
2937 
2938 
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 #include "types.h"
2951 #include "defs.h"
2952 #include "param.h"
2953 #include "memlayout.h"
2954 #include "mmu.h"
2955 #include "proc.h"
2956 #include "x86.h"
2957 #include "traps.h"
2958 #include "spinlock.h"
2959 
2960 
2961 struct gatedesc idt[256];
2962 extern uint vectors[];  
2963 struct spinlock tickslock;
2964 uint ticks;
2965 
2966 void
2967 tvinit(void)
2968 {
2969   int i;
2970 
2971   for(i = 0; i < 256; i++)
2972     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
2973   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
2974 
2975   initlock(&tickslock, "time");
2976 }
2977 
2978 void
2979 idtinit(void)
2980 {
2981   lidt(idt, sizeof(idt));
2982 }
2983 
2984 void
2985 trap(struct trapframe *tf)
2986 {
2987   if(tf->trapno == T_SYSCALL){
2988     if(myproc()->killed)
2989       exit();
2990     myproc()->tf = tf;
2991     syscall();
2992     if(myproc()->killed)
2993       exit();
2994     return;
2995   }
2996 
2997   switch(tf->trapno){
2998   case T_IRQ0 + IRQ_TIMER:
2999     if(cpuid() == 0){
3000       acquire(&tickslock);
3001       ticks++;
3002       wakeup(&ticks);
3003       release(&tickslock);
3004     }
3005     lapiceoi();
3006     break;
3007   case T_IRQ0 + IRQ_IDE:
3008     ideintr();
3009     lapiceoi();
3010     break;
3011   case T_IRQ0 + IRQ_IDE+1:
3012     
3013     break;
3014   case T_IRQ0 + IRQ_KBD:
3015     kbdintr();
3016     lapiceoi();
3017     break;
3018   case T_IRQ0 + IRQ_COM1:
3019     uartintr();
3020     lapiceoi();
3021     break;
3022   case T_IRQ0 + 7:
3023   case T_IRQ0 + IRQ_SPURIOUS:
3024     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3025             cpuid(), tf->cs, tf->eip);
3026     lapiceoi();
3027     break;
3028 
3029   default:
3030     if(myproc() == 0 || (tf->cs&3) == 0){
3031       
3032       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3033               tf->trapno, cpuid(), tf->eip, rcr2());
3034       panic("trap");
3035     }
3036     
3037     cprintf("pid %d %s: trap %d err %d on cpu %d "
3038             "eip 0x%x addr 0x%x--kill proc\n",
3039             myproc()->pid, myproc()->name, tf->trapno,
3040             tf->err, cpuid(), tf->eip, rcr2());
3041     myproc()->killed = 1;
3042   }
3043 
3044   
3045   
3046   
3047   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3048     exit();
3049 
3050   
3051   
3052   if(myproc() && myproc()->state == RUNNING &&
3053      tf->trapno == T_IRQ0+IRQ_TIMER)
3054     yield();
3055 
3056   
3057   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3058     exit();
3059 }
3060 
3061 
3062 
3063 
3064 
3065 
3066 
3067 
3068 
3069 
3070 
3071 
3072 
3073 
3074 
3075 
3076 
3077 
3078 
3079 
3080 
3081 
3082 
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 
3101 #define SYS_fork    1
3102 #define SYS_exit    2
3103 #define SYS_wait    3
3104 #define SYS_pipe    4
3105 #define SYS_read    5
3106 #define SYS_kill    6
3107 #define SYS_exec    7
3108 #define SYS_fstat   8
3109 #define SYS_chdir   9
3110 #define SYS_dup    10
3111 #define SYS_getpid 11
3112 #define SYS_sbrk   12
3113 #define SYS_sleep  13
3114 #define SYS_uptime 14
3115 #define SYS_open   15
3116 #define SYS_write  16
3117 #define SYS_mknod  17
3118 #define SYS_unlink 18
3119 #define SYS_link   19
3120 #define SYS_mkdir  20
3121 #define SYS_close  21
3122 
3123 
3124 
3125 
3126 
3127 
3128 
3129 
3130 
3131 
3132 
3133 
3134 
3135 
3136 
3137 
3138 
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 #include "types.h"
3151 #include "defs.h"
3152 #include "param.h"
3153 #include "memlayout.h"
3154 #include "mmu.h"
3155 #include "proc.h"
3156 #include "x86.h"
3157 #include "syscall.h"
3158 
3159 
3160 
3161 
3162 
3163 
3164 
3165 
3166 int
3167 fetchint(uint addr, int *ip)
3168 {
3169   struct proc *curproc = myproc();
3170 
3171   if(addr >= curproc->sz || addr+4 > curproc->sz)
3172     return -1;
3173   *ip = *(int*)(addr);
3174   return 0;
3175 }
3176 
3177 
3178 
3179 
3180 int
3181 fetchstr(uint addr, char **pp)
3182 {
3183   char *s, *ep;
3184   struct proc *curproc = myproc();
3185 
3186   if(addr >= curproc->sz)
3187     return -1;
3188   *pp = (char*)addr;
3189   ep = (char*)curproc->sz;
3190   for(s = *pp; s < ep; s++){
3191     if(*s == 0)
3192       return s - *pp;
3193   }
3194   return -1;
3195 }
3196 
3197 
3198 
3199 
3200 
3201 int
3202 argint(int n, int *ip)
3203 {
3204   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3205 }
3206 
3207 
3208 
3209 
3210 int
3211 argptr(int n, char **pp, int size)
3212 {
3213   int i;
3214   struct proc *curproc = myproc();
3215 
3216   if(argint(n, &i) < 0)
3217     return -1;
3218   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3219     return -1;
3220   *pp = (char*)i;
3221   return 0;
3222 }
3223 
3224 
3225 
3226 
3227 
3228 int
3229 argstr(int n, char **pp)
3230 {
3231   int addr;
3232   if(argint(n, &addr) < 0)
3233     return -1;
3234   return fetchstr(addr, pp);
3235 }
3236 
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 extern int sys_chdir(void);
3251 extern int sys_close(void);
3252 extern int sys_dup(void);
3253 extern int sys_exec(void);
3254 extern int sys_exit(void);
3255 extern int sys_fork(void);
3256 extern int sys_fstat(void);
3257 extern int sys_getpid(void);
3258 extern int sys_kill(void);
3259 extern int sys_link(void);
3260 extern int sys_mkdir(void);
3261 extern int sys_mknod(void);
3262 extern int sys_open(void);
3263 extern int sys_pipe(void);
3264 extern int sys_read(void);
3265 extern int sys_sbrk(void);
3266 extern int sys_sleep(void);
3267 extern int sys_unlink(void);
3268 extern int sys_wait(void);
3269 extern int sys_write(void);
3270 extern int sys_uptime(void);
3271 
3272 static int (*syscalls[])(void) = {
3273 [SYS_fork]    sys_fork,
3274 [SYS_exit]    sys_exit,
3275 [SYS_wait]    sys_wait,
3276 [SYS_pipe]    sys_pipe,
3277 [SYS_read]    sys_read,
3278 [SYS_kill]    sys_kill,
3279 [SYS_exec]    sys_exec,
3280 [SYS_fstat]   sys_fstat,
3281 [SYS_chdir]   sys_chdir,
3282 [SYS_dup]     sys_dup,
3283 [SYS_getpid]  sys_getpid,
3284 [SYS_sbrk]    sys_sbrk,
3285 [SYS_sleep]   sys_sleep,
3286 [SYS_uptime]  sys_uptime,
3287 [SYS_open]    sys_open,
3288 [SYS_write]   sys_write,
3289 [SYS_mknod]   sys_mknod,
3290 [SYS_unlink]  sys_unlink,
3291 [SYS_link]    sys_link,
3292 [SYS_mkdir]   sys_mkdir,
3293 [SYS_close]   sys_close,
3294 };
3295 
3296 
3297 
3298 
3299 
3300 void
3301 syscall(void)
3302 {
3303   int num;
3304   struct proc *curproc = myproc();
3305 
3306   num = curproc->tf->eax;
3307   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3308     curproc->tf->eax = syscalls[num]();
3309   } else {
3310     cprintf("%d %s: unknown sys call %d\n",
3311             curproc->pid, curproc->name, num);
3312     curproc->tf->eax = -1;
3313   }
3314 }
3315 
3316 
3317 
3318 
3319 
3320 
3321 
3322 
3323 
3324 
3325 
3326 
3327 
3328 
3329 
3330 
3331 
3332 
3333 
3334 
3335 
3336 
3337 
3338 
3339 
3340 
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 #include "types.h"
3351 #include "x86.h"
3352 #include "defs.h"
3353 #include "date.h"
3354 #include "param.h"
3355 #include "memlayout.h"
3356 #include "mmu.h"
3357 #include "proc.h"
3358 
3359 int
3360 sys_fork(void)
3361 {
3362   return fork();
3363 }
3364 
3365 int
3366 sys_exit(void)
3367 {
3368   exit();
3369   return 0;  
3370 }
3371 
3372 int
3373 sys_wait(void)
3374 {
3375   return wait();
3376 }
3377 
3378 int
3379 sys_kill(void)
3380 {
3381   int pid;
3382 
3383   if(argint(0, &pid) < 0)
3384     return -1;
3385   return kill(pid);
3386 }
3387 
3388 int
3389 sys_getpid(void)
3390 {
3391   return myproc()->pid;
3392 }
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 int
3401 sys_sbrk(void)
3402 {
3403   int addr;
3404   int n;
3405 
3406   if(argint(0, &n) < 0)
3407     return -1;
3408   addr = myproc()->sz;
3409   if(growproc(n) < 0)
3410     return -1;
3411   return addr;
3412 }
3413 
3414 int
3415 sys_sleep(void)
3416 {
3417   int n;
3418   uint ticks0;
3419 
3420   if(argint(0, &n) < 0)
3421     return -1;
3422   acquire(&tickslock);
3423   ticks0 = ticks;
3424   while(ticks - ticks0 < n){
3425     if(myproc()->killed){
3426       release(&tickslock);
3427       return -1;
3428     }
3429     sleep(&ticks, &tickslock);
3430   }
3431   release(&tickslock);
3432   return 0;
3433 }
3434 
3435 
3436 
3437 int
3438 sys_uptime(void)
3439 {
3440   uint xticks;
3441 
3442   acquire(&tickslock);
3443   xticks = ticks;
3444   release(&tickslock);
3445   return xticks;
3446 }
3447 
3448 
3449 
3450 struct buf {
3451   int flags;
3452   uint dev;
3453   uint blockno;
3454   struct sleeplock lock;
3455   uint refcnt;
3456   struct buf *prev; 
3457   struct buf *next;
3458   struct buf *qnext; 
3459   uchar data[BSIZE];
3460 };
3461 #define B_VALID 0x2  
3462 #define B_DIRTY 0x4  
3463 
3464 
3465 
3466 
3467 
3468 
3469 
3470 
3471 
3472 
3473 
3474 
3475 
3476 
3477 
3478 
3479 
3480 
3481 
3482 
3483 
3484 
3485 
3486 
3487 
3488 
3489 
3490 
3491 
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 
3501 struct sleeplock {
3502   uint locked;       
3503   struct spinlock lk; 
3504 
3505   
3506   char *name;        
3507   int pid;           
3508 };
3509 
3510 
3511 
3512 
3513 
3514 
3515 
3516 
3517 
3518 
3519 
3520 
3521 
3522 
3523 
3524 
3525 
3526 
3527 
3528 
3529 
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 #define O_RDONLY  0x000
3551 #define O_WRONLY  0x001
3552 #define O_RDWR    0x002
3553 #define O_CREATE  0x200
3554 
3555 
3556 
3557 
3558 
3559 
3560 
3561 
3562 
3563 
3564 
3565 
3566 
3567 
3568 
3569 
3570 
3571 
3572 
3573 
3574 
3575 
3576 
3577 
3578 
3579 
3580 
3581 
3582 
3583 
3584 
3585 
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 #define T_DIR  1   
3601 #define T_FILE 2   
3602 #define T_DEV  3   
3603 
3604 struct stat {
3605   short type;  
3606   int dev;     
3607   uint ino;    
3608   short nlink; 
3609   uint size;   
3610 };
3611 
3612 
3613 
3614 
3615 
3616 
3617 
3618 
3619 
3620 
3621 
3622 
3623 
3624 
3625 
3626 
3627 
3628 
3629 
3630 
3631 
3632 
3633 
3634 
3635 
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 
3651 
3652 
3653 
3654 #define ROOTINO 1  
3655 #define BSIZE 512  
3656 
3657 
3658 
3659 
3660 
3661 
3662 
3663 struct superblock {
3664   uint size;         
3665   uint nblocks;      
3666   uint ninodes;      
3667   uint nlog;         
3668   uint logstart;     
3669   uint inodestart;   
3670   uint bmapstart;    
3671 };
3672 
3673 #define NDIRECT 12
3674 #define NINDIRECT (BSIZE / sizeof(uint))
3675 #define MAXFILE (NDIRECT + NINDIRECT)
3676 
3677 
3678 struct dinode {
3679   short type;           
3680   short major;          
3681   short minor;          
3682   short nlink;          
3683   uint size;            
3684   uint addrs[NDIRECT+1];   
3685 };
3686 
3687 
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 
3701 #define IPB           (BSIZE / sizeof(struct dinode))
3702 
3703 
3704 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
3705 
3706 
3707 #define BPB           (BSIZE*8)
3708 
3709 
3710 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
3711 
3712 
3713 #define DIRSIZ 14
3714 
3715 struct dirent {
3716   ushort inum;
3717   char name[DIRSIZ];
3718 };
3719 
3720 
3721 
3722 
3723 
3724 
3725 
3726 
3727 
3728 
3729 
3730 
3731 
3732 
3733 
3734 
3735 
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 struct file {
3751   enum { FD_NONE, FD_PIPE, FD_INODE } type;
3752   int ref; 
3753   char readable;
3754   char writable;
3755   struct pipe *pipe;
3756   struct inode *ip;
3757   uint off;
3758 };
3759 
3760 
3761 
3762 struct inode {
3763   uint dev;           
3764   uint inum;          
3765   int ref;            
3766   struct sleeplock lock; 
3767   int valid;          
3768 
3769   short type;         
3770   short major;
3771   short minor;
3772   short nlink;
3773   uint size;
3774   uint addrs[NDIRECT+1];
3775 };
3776 
3777 
3778 
3779 struct devsw {
3780   int (*read)(struct inode*, char*, int);
3781   int (*write)(struct inode*, char*, int);
3782 };
3783 
3784 extern struct devsw devsw[];
3785 
3786 #define CONSOLE 1
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 
3801 
3802 #include "types.h"
3803 #include "defs.h"
3804 #include "param.h"
3805 #include "memlayout.h"
3806 #include "mmu.h"
3807 #include "proc.h"
3808 #include "x86.h"
3809 #include "traps.h"
3810 #include "spinlock.h"
3811 #include "sleeplock.h"
3812 #include "fs.h"
3813 #include "buf.h"
3814 
3815 #define SECTOR_SIZE   512
3816 #define IDE_BSY       0x80
3817 #define IDE_DRDY      0x40
3818 #define IDE_DF        0x20
3819 #define IDE_ERR       0x01
3820 
3821 #define IDE_CMD_READ  0x20
3822 #define IDE_CMD_WRITE 0x30
3823 #define IDE_CMD_RDMUL 0xc4
3824 #define IDE_CMD_WRMUL 0xc5
3825 
3826 
3827 
3828 
3829 
3830 static struct spinlock idelock;
3831 static struct buf *idequeue;
3832 
3833 static int havedisk1;
3834 static void idestart(struct buf*);
3835 
3836 
3837 static int
3838 idewait(int checkerr)
3839 {
3840   int r;
3841 
3842   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
3843     ;
3844   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
3845     return -1;
3846   return 0;
3847 }
3848 
3849 
3850 void
3851 ideinit(void)
3852 {
3853   int i;
3854 
3855   initlock(&idelock, "ide");
3856   ioapicenable(IRQ_IDE, ncpu - 1);
3857   idewait(0);
3858 
3859   
3860   outb(0x1f6, 0xe0 | (1<<4));
3861   for(i=0; i<1000; i++){
3862     if(inb(0x1f7) != 0){
3863       havedisk1 = 1;
3864       break;
3865     }
3866   }
3867 
3868   
3869   outb(0x1f6, 0xe0 | (0<<4));
3870 }
3871 
3872 
3873 static void
3874 idestart(struct buf *b)
3875 {
3876   if(b == 0)
3877     panic("idestart");
3878   if(b->blockno >= FSSIZE)
3879     panic("incorrect blockno");
3880   int sector_per_block =  BSIZE/SECTOR_SIZE;
3881   int sector = b->blockno * sector_per_block;
3882   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
3883   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
3884 
3885   if (sector_per_block > 7) panic("idestart");
3886 
3887   idewait(0);
3888   outb(0x3f6, 0);  
3889   outb(0x1f2, sector_per_block);  
3890   outb(0x1f3, sector & 0xff);
3891   outb(0x1f4, (sector >> 8) & 0xff);
3892   outb(0x1f5, (sector >> 16) & 0xff);
3893   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
3894   if(b->flags & B_DIRTY){
3895     outb(0x1f7, write_cmd);
3896     outsl(0x1f0, b->data, BSIZE/4);
3897   } else {
3898     outb(0x1f7, read_cmd);
3899   }
3900 }
3901 
3902 
3903 void
3904 ideintr(void)
3905 {
3906   struct buf *b;
3907 
3908   
3909   acquire(&idelock);
3910 
3911   if((b = idequeue) == 0){
3912     release(&idelock);
3913     return;
3914   }
3915   idequeue = b->qnext;
3916 
3917   
3918   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
3919     insl(0x1f0, b->data, BSIZE/4);
3920 
3921   
3922   b->flags |= B_VALID;
3923   b->flags &= ~B_DIRTY;
3924   wakeup(b);
3925 
3926   
3927   if(idequeue != 0)
3928     idestart(idequeue);
3929 
3930   release(&idelock);
3931 }
3932 
3933 
3934 
3935 
3936 void
3937 iderw(struct buf *b)
3938 {
3939   struct buf **pp;
3940 
3941   if(!holdingsleep(&b->lock))
3942     panic("iderw: buf not locked");
3943   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
3944     panic("iderw: nothing to do");
3945   if(b->dev != 0 && !havedisk1)
3946     panic("iderw: ide disk 1 not present");
3947 
3948   acquire(&idelock);  
3949 
3950   
3951   b->qnext = 0;
3952   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
3953     ;
3954   *pp = b;
3955 
3956   
3957   if(idequeue == b)
3958     idestart(b);
3959 
3960   
3961   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
3962     sleep(b, &idelock);
3963   }
3964 
3965 
3966   release(&idelock);
3967 }
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 
4002 
4003 
4004 
4005 
4006 
4007 
4008 
4009 
4010 
4011 
4012 
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 #include "types.h"
4021 #include "defs.h"
4022 #include "param.h"
4023 #include "spinlock.h"
4024 #include "sleeplock.h"
4025 #include "fs.h"
4026 #include "buf.h"
4027 
4028 struct {
4029   struct spinlock lock;
4030   struct buf buf[NBUF];
4031 
4032   
4033   
4034   struct buf head;
4035 } bcache;
4036 
4037 void
4038 binit(void)
4039 {
4040   struct buf *b;
4041 
4042   initlock(&bcache.lock, "bcache");
4043 
4044   
4045   bcache.head.prev = &bcache.head;
4046   bcache.head.next = &bcache.head;
4047   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4048     b->next = bcache.head.next;
4049     b->prev = &bcache.head;
4050     initsleeplock(&b->lock, "buffer");
4051     bcache.head.next->prev = b;
4052     bcache.head.next = b;
4053   }
4054 }
4055 
4056 
4057 
4058 
4059 static struct buf*
4060 bget(uint dev, uint blockno)
4061 {
4062   struct buf *b;
4063 
4064   acquire(&bcache.lock);
4065 
4066   
4067   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4068     if(b->dev == dev && b->blockno == blockno){
4069       b->refcnt++;
4070       release(&bcache.lock);
4071       acquiresleep(&b->lock);
4072       return b;
4073     }
4074   }
4075 
4076   
4077   
4078   
4079   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4080     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4081       b->dev = dev;
4082       b->blockno = blockno;
4083       b->flags = 0;
4084       b->refcnt = 1;
4085       release(&bcache.lock);
4086       acquiresleep(&b->lock);
4087       return b;
4088     }
4089   }
4090   panic("bget: no buffers");
4091 }
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 
4101 struct buf*
4102 bread(uint dev, uint blockno)
4103 {
4104   struct buf *b;
4105 
4106   b = bget(dev, blockno);
4107   if((b->flags & B_VALID) == 0) {
4108     iderw(b);
4109   }
4110   return b;
4111 }
4112 
4113 
4114 void
4115 bwrite(struct buf *b)
4116 {
4117   if(!holdingsleep(&b->lock))
4118     panic("bwrite");
4119   b->flags |= B_DIRTY;
4120   iderw(b);
4121 }
4122 
4123 
4124 
4125 void
4126 brelse(struct buf *b)
4127 {
4128   if(!holdingsleep(&b->lock))
4129     panic("brelse");
4130 
4131   releasesleep(&b->lock);
4132 
4133   acquire(&bcache.lock);
4134   b->refcnt--;
4135   if (b->refcnt == 0) {
4136     
4137     b->next->prev = b->prev;
4138     b->prev->next = b->next;
4139     b->next = bcache.head.next;
4140     b->prev = &bcache.head;
4141     bcache.head.next->prev = b;
4142     bcache.head.next = b;
4143   }
4144 
4145   release(&bcache.lock);
4146 }
4147 
4148 
4149 
4150 
4151 
4152 #include "types.h"
4153 #include "defs.h"
4154 #include "param.h"
4155 #include "x86.h"
4156 #include "memlayout.h"
4157 #include "mmu.h"
4158 #include "proc.h"
4159 #include "spinlock.h"
4160 #include "sleeplock.h"
4161 
4162 void
4163 initsleeplock(struct sleeplock *lk, char *name)
4164 {
4165   initlock(&lk->lk, "sleep lock");
4166   lk->name = name;
4167   lk->locked = 0;
4168   lk->pid = 0;
4169 }
4170 
4171 void
4172 acquiresleep(struct sleeplock *lk)
4173 {
4174   acquire(&lk->lk);
4175   while (lk->locked) {
4176     sleep(lk, &lk->lk);
4177   }
4178   lk->locked = 1;
4179   lk->pid = myproc()->pid;
4180   release(&lk->lk);
4181 }
4182 
4183 void
4184 releasesleep(struct sleeplock *lk)
4185 {
4186   acquire(&lk->lk);
4187   lk->locked = 0;
4188   lk->pid = 0;
4189   wakeup(lk);
4190   release(&lk->lk);
4191 }
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 int
4201 holdingsleep(struct sleeplock *lk)
4202 {
4203   int r;
4204 
4205   acquire(&lk->lk);
4206   r = lk->locked && (lk->pid == myproc()->pid);
4207   release(&lk->lk);
4208   return r;
4209 }
4210 
4211 
4212 
4213 
4214 
4215 
4216 
4217 
4218 
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 #include "types.h"
4251 #include "defs.h"
4252 #include "param.h"
4253 #include "spinlock.h"
4254 #include "sleeplock.h"
4255 #include "fs.h"
4256 #include "buf.h"
4257 
4258 
4259 
4260 
4261 
4262 
4263 
4264 
4265 
4266 
4267 
4268 
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283 struct logheader {
4284   int n;
4285   int block[LOGSIZE];
4286 };
4287 
4288 struct log {
4289   struct spinlock lock;
4290   int start;
4291   int size;
4292   int outstanding; 
4293   int committing;  
4294   int dev;
4295   struct logheader lh;
4296 };
4297 
4298 
4299 
4300 struct log log;
4301 
4302 static void recover_from_log(void);
4303 static void commit();
4304 
4305 void
4306 initlog(int dev)
4307 {
4308   if (sizeof(struct logheader) >= BSIZE)
4309     panic("initlog: too big logheader");
4310 
4311   struct superblock sb;
4312   initlock(&log.lock, "log");
4313   readsb(dev, &sb);
4314   log.start = sb.logstart;
4315   log.size = sb.nlog;
4316   log.dev = dev;
4317   recover_from_log();
4318 }
4319 
4320 
4321 static void
4322 install_trans(void)
4323 {
4324   int tail;
4325 
4326   for (tail = 0; tail < log.lh.n; tail++) {
4327     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4328     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4329     memmove(dbuf->data, lbuf->data, BSIZE);  
4330     bwrite(dbuf);  
4331     brelse(lbuf);
4332     brelse(dbuf);
4333   }
4334 }
4335 
4336 
4337 static void
4338 read_head(void)
4339 {
4340   struct buf *buf = bread(log.dev, log.start);
4341   struct logheader *lh = (struct logheader *) (buf->data);
4342   int i;
4343   log.lh.n = lh->n;
4344   for (i = 0; i < log.lh.n; i++) {
4345     log.lh.block[i] = lh->block[i];
4346   }
4347   brelse(buf);
4348 }
4349 
4350 
4351 
4352 
4353 static void
4354 write_head(void)
4355 {
4356   struct buf *buf = bread(log.dev, log.start);
4357   struct logheader *hb = (struct logheader *) (buf->data);
4358   int i;
4359   hb->n = log.lh.n;
4360   for (i = 0; i < log.lh.n; i++) {
4361     hb->block[i] = log.lh.block[i];
4362   }
4363   bwrite(buf);
4364   brelse(buf);
4365 }
4366 
4367 static void
4368 recover_from_log(void)
4369 {
4370   read_head();
4371   install_trans(); 
4372   log.lh.n = 0;
4373   write_head(); 
4374 }
4375 
4376 
4377 void
4378 begin_op(void)
4379 {
4380   acquire(&log.lock);
4381   while(1){
4382     if(log.committing){
4383       sleep(&log, &log.lock);
4384     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4385       
4386       sleep(&log, &log.lock);
4387     } else {
4388       log.outstanding += 1;
4389       release(&log.lock);
4390       break;
4391     }
4392   }
4393 }
4394 
4395 
4396 
4397 
4398 
4399 
4400 
4401 
4402 void
4403 end_op(void)
4404 {
4405   int do_commit = 0;
4406 
4407   acquire(&log.lock);
4408   log.outstanding -= 1;
4409   if(log.committing)
4410     panic("log.committing");
4411   if(log.outstanding == 0){
4412     do_commit = 1;
4413     log.committing = 1;
4414   } else {
4415     
4416     
4417     
4418     wakeup(&log);
4419   }
4420   release(&log.lock);
4421 
4422   if(do_commit){
4423     
4424     
4425     commit();
4426     acquire(&log.lock);
4427     log.committing = 0;
4428     wakeup(&log);
4429     release(&log.lock);
4430   }
4431 }
4432 
4433 
4434 static void
4435 write_log(void)
4436 {
4437   int tail;
4438 
4439   for (tail = 0; tail < log.lh.n; tail++) {
4440     struct buf *to = bread(log.dev, log.start+tail+1); 
4441     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4442     memmove(to->data, from->data, BSIZE);
4443     bwrite(to);  
4444     brelse(from);
4445     brelse(to);
4446   }
4447 }
4448 
4449 
4450 static void
4451 commit()
4452 {
4453   if (log.lh.n > 0) {
4454     write_log();     
4455     write_head();    
4456     install_trans(); 
4457     log.lh.n = 0;
4458     write_head();    
4459   }
4460 }
4461 
4462 
4463 
4464 
4465 
4466 
4467 
4468 
4469 
4470 
4471 void
4472 log_write(struct buf *b)
4473 {
4474   int i;
4475 
4476   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4477     panic("too big a transaction");
4478   if (log.outstanding < 1)
4479     panic("log_write outside of trans");
4480 
4481   acquire(&log.lock);
4482   for (i = 0; i < log.lh.n; i++) {
4483     if (log.lh.block[i] == b->blockno)   
4484       break;
4485   }
4486   log.lh.block[i] = b->blockno;
4487   if (i == log.lh.n)
4488     log.lh.n++;
4489   b->flags |= B_DIRTY; 
4490   release(&log.lock);
4491 }
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 
4504 
4505 
4506 
4507 
4508 
4509 
4510 
4511 #include "types.h"
4512 #include "defs.h"
4513 #include "param.h"
4514 #include "stat.h"
4515 #include "mmu.h"
4516 #include "proc.h"
4517 #include "spinlock.h"
4518 #include "sleeplock.h"
4519 #include "fs.h"
4520 #include "buf.h"
4521 #include "file.h"
4522 
4523 #define min(a, b) ((a) < (b) ? (a) : (b))
4524 static void itrunc(struct inode*);
4525 
4526 
4527 struct superblock sb;
4528 
4529 
4530 void
4531 readsb(int dev, struct superblock *sb)
4532 {
4533   struct buf *bp;
4534 
4535   bp = bread(dev, 1);
4536   memmove(sb, bp->data, sizeof(*sb));
4537   brelse(bp);
4538 }
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 
4551 static void
4552 bzero(int dev, int bno)
4553 {
4554   struct buf *bp;
4555 
4556   bp = bread(dev, bno);
4557   memset(bp->data, 0, BSIZE);
4558   log_write(bp);
4559   brelse(bp);
4560 }
4561 
4562 
4563 
4564 
4565 static uint
4566 balloc(uint dev)
4567 {
4568   int b, bi, m;
4569   struct buf *bp;
4570 
4571   bp = 0;
4572   for(b = 0; b < sb.size; b += BPB){
4573     bp = bread(dev, BBLOCK(b, sb));
4574     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
4575       m = 1 << (bi % 8);
4576       if((bp->data[bi/8] & m) == 0){  
4577         bp->data[bi/8] |= m;  
4578         log_write(bp);
4579         brelse(bp);
4580         bzero(dev, b + bi);
4581         return b + bi;
4582       }
4583     }
4584     brelse(bp);
4585   }
4586   panic("balloc: out of blocks");
4587 }
4588 
4589 
4590 
4591 
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 static void
4602 bfree(int dev, uint b)
4603 {
4604   struct buf *bp;
4605   int bi, m;
4606 
4607   bp = bread(dev, BBLOCK(b, sb));
4608   bi = b % BPB;
4609   m = 1 << (bi % 8);
4610   if((bp->data[bi/8] & m) == 0)
4611     panic("freeing free block");
4612   bp->data[bi/8] &= ~m;
4613   log_write(bp);
4614   brelse(bp);
4615 }
4616 
4617 
4618 
4619 
4620 
4621 
4622 
4623 
4624 
4625 
4626 
4627 
4628 
4629 
4630 
4631 
4632 
4633 
4634 
4635 
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 
4653 
4654 
4655 
4656 
4657 
4658 
4659 
4660 
4661 
4662 
4663 
4664 
4665 
4666 
4667 
4668 
4669 
4670 
4671 
4672 
4673 
4674 
4675 
4676 
4677 
4678 
4679 
4680 
4681 
4682 
4683 
4684 
4685 
4686 struct {
4687   struct spinlock lock;
4688   struct inode inode[NINODE];
4689 } icache;
4690 
4691 void
4692 iinit(int dev)
4693 {
4694   int i = 0;
4695 
4696   initlock(&icache.lock, "icache");
4697   for(i = 0; i < NINODE; i++) {
4698     initsleeplock(&icache.inode[i].lock, "inode");
4699   }
4700   readsb(dev, &sb);
4701   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
4702  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
4703           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
4704           sb.bmapstart);
4705 }
4706 
4707 static struct inode* iget(uint dev, uint inum);
4708 
4709 
4710 
4711 
4712 struct inode*
4713 ialloc(uint dev, short type)
4714 {
4715   int inum;
4716   struct buf *bp;
4717   struct dinode *dip;
4718 
4719   for(inum = 1; inum < sb.ninodes; inum++){
4720     bp = bread(dev, IBLOCK(inum, sb));
4721     dip = (struct dinode*)bp->data + inum%IPB;
4722     if(dip->type == 0){  
4723       memset(dip, 0, sizeof(*dip));
4724       dip->type = type;
4725       log_write(bp);   
4726       brelse(bp);
4727       return iget(dev, inum);
4728     }
4729     brelse(bp);
4730   }
4731   panic("ialloc: no inodes");
4732 }
4733 
4734 
4735 
4736 
4737 
4738 void
4739 iupdate(struct inode *ip)
4740 {
4741   struct buf *bp;
4742   struct dinode *dip;
4743 
4744   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
4745   dip = (struct dinode*)bp->data + ip->inum%IPB;
4746   dip->type = ip->type;
4747   dip->major = ip->major;
4748   dip->minor = ip->minor;
4749   dip->nlink = ip->nlink;
4750   dip->size = ip->size;
4751   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
4752   log_write(bp);
4753   brelse(bp);
4754 }
4755 
4756 
4757 
4758 
4759 static struct inode*
4760 iget(uint dev, uint inum)
4761 {
4762   struct inode *ip, *empty;
4763 
4764   acquire(&icache.lock);
4765 
4766   
4767   empty = 0;
4768   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
4769     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
4770       ip->ref++;
4771       release(&icache.lock);
4772       return ip;
4773     }
4774     if(empty == 0 && ip->ref == 0)    
4775       empty = ip;
4776   }
4777 
4778   
4779   if(empty == 0)
4780     panic("iget: no inodes");
4781 
4782   ip = empty;
4783   ip->dev = dev;
4784   ip->inum = inum;
4785   ip->ref = 1;
4786   ip->valid = 0;
4787   release(&icache.lock);
4788 
4789   return ip;
4790 }
4791 
4792 
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800 
4801 
4802 struct inode*
4803 idup(struct inode *ip)
4804 {
4805   acquire(&icache.lock);
4806   ip->ref++;
4807   release(&icache.lock);
4808   return ip;
4809 }
4810 
4811 
4812 
4813 void
4814 ilock(struct inode *ip)
4815 {
4816   struct buf *bp;
4817   struct dinode *dip;
4818 
4819   if(ip == 0 || ip->ref < 1)
4820     panic("ilock");
4821 
4822   acquiresleep(&ip->lock);
4823 
4824   if(ip->valid == 0){
4825     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
4826     dip = (struct dinode*)bp->data + ip->inum%IPB;
4827     ip->type = dip->type;
4828     ip->major = dip->major;
4829     ip->minor = dip->minor;
4830     ip->nlink = dip->nlink;
4831     ip->size = dip->size;
4832     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
4833     brelse(bp);
4834     ip->valid = 1;
4835     if(ip->type == 0)
4836       panic("ilock: no type");
4837   }
4838 }
4839 
4840 
4841 void
4842 iunlock(struct inode *ip)
4843 {
4844   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
4845     panic("iunlock");
4846 
4847   releasesleep(&ip->lock);
4848 }
4849 
4850 
4851 
4852 
4853 
4854 
4855 
4856 
4857 void
4858 iput(struct inode *ip)
4859 {
4860   acquiresleep(&ip->lock);
4861   if(ip->valid && ip->nlink == 0){
4862     acquire(&icache.lock);
4863     int r = ip->ref;
4864     release(&icache.lock);
4865     if(r == 1){
4866       
4867       itrunc(ip);
4868       ip->type = 0;
4869       iupdate(ip);
4870       ip->valid = 0;
4871     }
4872   }
4873   releasesleep(&ip->lock);
4874 
4875   acquire(&icache.lock);
4876   ip->ref--;
4877   release(&icache.lock);
4878 }
4879 
4880 
4881 void
4882 iunlockput(struct inode *ip)
4883 {
4884   iunlock(ip);
4885   iput(ip);
4886 }
4887 
4888 
4889 
4890 
4891 
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 
4903 
4904 
4905 
4906 
4907 
4908 
4909 static uint
4910 bmap(struct inode *ip, uint bn)
4911 {
4912   uint addr, *a;
4913   struct buf *bp;
4914 
4915   if(bn < NDIRECT){
4916     if((addr = ip->addrs[bn]) == 0)
4917       ip->addrs[bn] = addr = balloc(ip->dev);
4918     return addr;
4919   }
4920   bn -= NDIRECT;
4921 
4922   if(bn < NINDIRECT){
4923     
4924     if((addr = ip->addrs[NDIRECT]) == 0)
4925       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
4926     bp = bread(ip->dev, addr);
4927     a = (uint*)bp->data;
4928     if((addr = a[bn]) == 0){
4929       a[bn] = addr = balloc(ip->dev);
4930       log_write(bp);
4931     }
4932     brelse(bp);
4933     return addr;
4934   }
4935 
4936   panic("bmap: out of range");
4937 }
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 
4953 
4954 
4955 static void
4956 itrunc(struct inode *ip)
4957 {
4958   int i, j;
4959   struct buf *bp;
4960   uint *a;
4961 
4962   for(i = 0; i < NDIRECT; i++){
4963     if(ip->addrs[i]){
4964       bfree(ip->dev, ip->addrs[i]);
4965       ip->addrs[i] = 0;
4966     }
4967   }
4968 
4969   if(ip->addrs[NDIRECT]){
4970     bp = bread(ip->dev, ip->addrs[NDIRECT]);
4971     a = (uint*)bp->data;
4972     for(j = 0; j < NINDIRECT; j++){
4973       if(a[j])
4974         bfree(ip->dev, a[j]);
4975     }
4976     brelse(bp);
4977     bfree(ip->dev, ip->addrs[NDIRECT]);
4978     ip->addrs[NDIRECT] = 0;
4979   }
4980 
4981   ip->size = 0;
4982   iupdate(ip);
4983 }
4984 
4985 
4986 
4987 void
4988 stati(struct inode *ip, struct stat *st)
4989 {
4990   st->dev = ip->dev;
4991   st->ino = ip->inum;
4992   st->type = ip->type;
4993   st->nlink = ip->nlink;
4994   st->size = ip->size;
4995 }
4996 
4997 
4998 
4999 
5000 
5001 
5002 int
5003 readi(struct inode *ip, char *dst, uint off, uint n)
5004 {
5005   uint tot, m;
5006   struct buf *bp;
5007 
5008   if(ip->type == T_DEV){
5009     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5010       return -1;
5011     return devsw[ip->major].read(ip, dst, n);
5012   }
5013 
5014   if(off > ip->size || off + n < off)
5015     return -1;
5016   if(off + n > ip->size)
5017     n = ip->size - off;
5018 
5019   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5020     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5021     m = min(n - tot, BSIZE - off%BSIZE);
5022     memmove(dst, bp->data + off%BSIZE, m);
5023     brelse(bp);
5024   }
5025   return n;
5026 }
5027 
5028 
5029 
5030 int
5031 writei(struct inode *ip, char *src, uint off, uint n)
5032 {
5033   uint tot, m;
5034   struct buf *bp;
5035 
5036   if(ip->type == T_DEV){
5037     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5038       return -1;
5039     return devsw[ip->major].write(ip, src, n);
5040   }
5041 
5042   if(off > ip->size || off + n < off)
5043     return -1;
5044   if(off + n > MAXFILE*BSIZE)
5045     return -1;
5046 
5047 
5048 
5049 
5050   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5051     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5052     m = min(n - tot, BSIZE - off%BSIZE);
5053     memmove(bp->data + off%BSIZE, src, m);
5054     log_write(bp);
5055     brelse(bp);
5056   }
5057 
5058   if(n > 0 && off > ip->size){
5059     ip->size = off;
5060     iupdate(ip);
5061   }
5062   return n;
5063 }
5064 
5065 
5066 
5067 int
5068 namecmp(const char *s, const char *t)
5069 {
5070   return strncmp(s, t, DIRSIZ);
5071 }
5072 
5073 
5074 
5075 struct inode*
5076 dirlookup(struct inode *dp, char *name, uint *poff)
5077 {
5078   uint off, inum;
5079   struct dirent de;
5080 
5081   if(dp->type != T_DIR)
5082     panic("dirlookup not DIR");
5083 
5084   for(off = 0; off < dp->size; off += sizeof(de)){
5085     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5086       panic("dirlookup read");
5087     if(de.inum == 0)
5088       continue;
5089     if(namecmp(name, de.name) == 0){
5090       
5091       if(poff)
5092         *poff = off;
5093       inum = de.inum;
5094       return iget(dp->dev, inum);
5095     }
5096   }
5097 
5098   return 0;
5099 }
5100 
5101 int
5102 dirlink(struct inode *dp, char *name, uint inum)
5103 {
5104   int off;
5105   struct dirent de;
5106   struct inode *ip;
5107 
5108   
5109   if((ip = dirlookup(dp, name, 0)) != 0){
5110     iput(ip);
5111     return -1;
5112   }
5113 
5114   
5115   for(off = 0; off < dp->size; off += sizeof(de)){
5116     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5117       panic("dirlink read");
5118     if(de.inum == 0)
5119       break;
5120   }
5121 
5122   strncpy(de.name, name, DIRSIZ);
5123   de.inum = inum;
5124   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5125     panic("dirlink");
5126 
5127   return 0;
5128 }
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 static char*
5145 skipelem(char *path, char *name)
5146 {
5147   char *s;
5148   int len;
5149 
5150   while(*path == '/')
5151     path++;
5152   if(*path == 0)
5153     return 0;
5154   s = path;
5155   while(*path != '/' && *path != 0)
5156     path++;
5157   len = path - s;
5158   if(len >= DIRSIZ)
5159     memmove(name, s, DIRSIZ);
5160   else {
5161     memmove(name, s, len);
5162     name[len] = 0;
5163   }
5164   while(*path == '/')
5165     path++;
5166   return path;
5167 }
5168 
5169 
5170 
5171 
5172 
5173 static struct inode*
5174 namex(char *path, int nameiparent, char *name)
5175 {
5176   struct inode *ip, *next;
5177 
5178   if(*path == '/')
5179     ip = iget(ROOTDEV, ROOTINO);
5180   else
5181     ip = idup(myproc()->cwd);
5182 
5183   while((path = skipelem(path, name)) != 0){
5184     ilock(ip);
5185     if(ip->type != T_DIR){
5186       iunlockput(ip);
5187       return 0;
5188     }
5189     if(nameiparent && *path == '\0'){
5190       
5191       iunlock(ip);
5192       return ip;
5193     }
5194     if((next = dirlookup(ip, name, 0)) == 0){
5195       iunlockput(ip);
5196       return 0;
5197     }
5198     iunlockput(ip);
5199     ip = next;
5200   }
5201   if(nameiparent){
5202     iput(ip);
5203     return 0;
5204   }
5205   return ip;
5206 }
5207 
5208 struct inode*
5209 namei(char *path)
5210 {
5211   char name[DIRSIZ];
5212   return namex(path, 0, name);
5213 }
5214 
5215 struct inode*
5216 nameiparent(char *path, char *name)
5217 {
5218   return namex(path, 1, name);
5219 }
5220 
5221 
5222 
5223 
5224 
5225 
5226 
5227 
5228 
5229 
5230 
5231 
5232 
5233 
5234 
5235 
5236 
5237 
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 
5252 
5253 
5254 #include "types.h"
5255 #include "defs.h"
5256 #include "param.h"
5257 #include "fs.h"
5258 #include "spinlock.h"
5259 #include "sleeplock.h"
5260 #include "file.h"
5261 
5262 struct devsw devsw[NDEV];
5263 struct {
5264   struct spinlock lock;
5265   struct file file[NFILE];
5266 } ftable;
5267 
5268 void
5269 fileinit(void)
5270 {
5271   initlock(&ftable.lock, "ftable");
5272 }
5273 
5274 
5275 struct file*
5276 filealloc(void)
5277 {
5278   struct file *f;
5279 
5280   acquire(&ftable.lock);
5281   for(f = ftable.file; f < ftable.file + NFILE; f++){
5282     if(f->ref == 0){
5283       f->ref = 1;
5284       release(&ftable.lock);
5285       return f;
5286     }
5287   }
5288   release(&ftable.lock);
5289   return 0;
5290 }
5291 
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 struct file*
5302 filedup(struct file *f)
5303 {
5304   acquire(&ftable.lock);
5305   if(f->ref < 1)
5306     panic("filedup");
5307   f->ref++;
5308   release(&ftable.lock);
5309   return f;
5310 }
5311 
5312 
5313 void
5314 fileclose(struct file *f)
5315 {
5316   struct file ff;
5317 
5318   acquire(&ftable.lock);
5319   if(f->ref < 1)
5320     panic("fileclose");
5321   if(--f->ref > 0){
5322     release(&ftable.lock);
5323     return;
5324   }
5325   ff = *f;
5326   f->ref = 0;
5327   f->type = FD_NONE;
5328   release(&ftable.lock);
5329 
5330   if(ff.type == FD_PIPE)
5331     pipeclose(ff.pipe, ff.writable);
5332   else if(ff.type == FD_INODE){
5333     begin_op();
5334     iput(ff.ip);
5335     end_op();
5336   }
5337 }
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 int
5352 filestat(struct file *f, struct stat *st)
5353 {
5354   if(f->type == FD_INODE){
5355     ilock(f->ip);
5356     stati(f->ip, st);
5357     iunlock(f->ip);
5358     return 0;
5359   }
5360   return -1;
5361 }
5362 
5363 
5364 int
5365 fileread(struct file *f, char *addr, int n)
5366 {
5367   int r;
5368 
5369   if(f->readable == 0)
5370     return -1;
5371   if(f->type == FD_PIPE)
5372     return piperead(f->pipe, addr, n);
5373   if(f->type == FD_INODE){
5374     ilock(f->ip);
5375     if((r = readi(f->ip, addr, f->off, n)) > 0)
5376       f->off += r;
5377     iunlock(f->ip);
5378     return r;
5379   }
5380   panic("fileread");
5381 }
5382 
5383 
5384 int
5385 filewrite(struct file *f, char *addr, int n)
5386 {
5387   int r;
5388 
5389   if(f->writable == 0)
5390     return -1;
5391   if(f->type == FD_PIPE)
5392     return pipewrite(f->pipe, addr, n);
5393   if(f->type == FD_INODE){
5394     
5395     
5396     
5397     
5398     
5399     
5400     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
5401     int i = 0;
5402     while(i < n){
5403       int n1 = n - i;
5404       if(n1 > max)
5405         n1 = max;
5406 
5407       begin_op();
5408       ilock(f->ip);
5409       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5410         f->off += r;
5411       iunlock(f->ip);
5412       end_op();
5413 
5414       if(r < 0)
5415         break;
5416       if(r != n1)
5417         panic("short filewrite");
5418       i += r;
5419     }
5420     return i == n ? n : -1;
5421   }
5422   panic("filewrite");
5423 }
5424 
5425 
5426 
5427 
5428 
5429 
5430 
5431 
5432 
5433 
5434 
5435 
5436 
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 
5454 
5455 
5456 #include "types.h"
5457 #include "defs.h"
5458 #include "param.h"
5459 #include "stat.h"
5460 #include "mmu.h"
5461 #include "proc.h"
5462 #include "fs.h"
5463 #include "spinlock.h"
5464 #include "sleeplock.h"
5465 #include "file.h"
5466 #include "fcntl.h"
5467 
5468 
5469 
5470 static int
5471 argfd(int n, int *pfd, struct file **pf)
5472 {
5473   int fd;
5474   struct file *f;
5475 
5476   if(argint(n, &fd) < 0)
5477     return -1;
5478   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
5479     return -1;
5480   if(pfd)
5481     *pfd = fd;
5482   if(pf)
5483     *pf = f;
5484   return 0;
5485 }
5486 
5487 
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 static int
5503 fdalloc(struct file *f)
5504 {
5505   int fd;
5506   struct proc *curproc = myproc();
5507 
5508   for(fd = 0; fd < NOFILE; fd++){
5509     if(curproc->ofile[fd] == 0){
5510       curproc->ofile[fd] = f;
5511       return fd;
5512     }
5513   }
5514   return -1;
5515 }
5516 
5517 int
5518 sys_dup(void)
5519 {
5520   struct file *f;
5521   int fd;
5522 
5523   if(argfd(0, 0, &f) < 0)
5524     return -1;
5525   if((fd=fdalloc(f)) < 0)
5526     return -1;
5527   filedup(f);
5528   return fd;
5529 }
5530 
5531 int
5532 sys_read(void)
5533 {
5534   struct file *f;
5535   int n;
5536   char *p;
5537 
5538   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5539     return -1;
5540   return fileread(f, p, n);
5541 }
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 int
5551 sys_write(void)
5552 {
5553   struct file *f;
5554   int n;
5555   char *p;
5556 
5557   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5558     return -1;
5559   return filewrite(f, p, n);
5560 }
5561 
5562 int
5563 sys_close(void)
5564 {
5565   int fd;
5566   struct file *f;
5567 
5568   if(argfd(0, &fd, &f) < 0)
5569     return -1;
5570   myproc()->ofile[fd] = 0;
5571   fileclose(f);
5572   return 0;
5573 }
5574 
5575 int
5576 sys_fstat(void)
5577 {
5578   struct file *f;
5579   struct stat *st;
5580 
5581   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
5582     return -1;
5583   return filestat(f, st);
5584 }
5585 
5586 
5587 
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 int
5602 sys_link(void)
5603 {
5604   char name[DIRSIZ], *new, *old;
5605   struct inode *dp, *ip;
5606 
5607   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
5608     return -1;
5609 
5610   begin_op();
5611   if((ip = namei(old)) == 0){
5612     end_op();
5613     return -1;
5614   }
5615 
5616   ilock(ip);
5617   if(ip->type == T_DIR){
5618     iunlockput(ip);
5619     end_op();
5620     return -1;
5621   }
5622 
5623   ip->nlink++;
5624   iupdate(ip);
5625   iunlock(ip);
5626 
5627   if((dp = nameiparent(new, name)) == 0)
5628     goto bad;
5629   ilock(dp);
5630   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
5631     iunlockput(dp);
5632     goto bad;
5633   }
5634   iunlockput(dp);
5635   iput(ip);
5636 
5637   end_op();
5638 
5639   return 0;
5640 
5641 bad:
5642   ilock(ip);
5643   ip->nlink--;
5644   iupdate(ip);
5645   iunlockput(ip);
5646   end_op();
5647   return -1;
5648 }
5649 
5650 
5651 static int
5652 isdirempty(struct inode *dp)
5653 {
5654   int off;
5655   struct dirent de;
5656 
5657   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
5658     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5659       panic("isdirempty: readi");
5660     if(de.inum != 0)
5661       return 0;
5662   }
5663   return 1;
5664 }
5665 
5666 int
5667 sys_unlink(void)
5668 {
5669   struct inode *ip, *dp;
5670   struct dirent de;
5671   char name[DIRSIZ], *path;
5672   uint off;
5673 
5674   if(argstr(0, &path) < 0)
5675     return -1;
5676 
5677   begin_op();
5678   if((dp = nameiparent(path, name)) == 0){
5679     end_op();
5680     return -1;
5681   }
5682 
5683   ilock(dp);
5684 
5685   
5686   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
5687     goto bad;
5688 
5689   if((ip = dirlookup(dp, name, &off)) == 0)
5690     goto bad;
5691   ilock(ip);
5692 
5693   if(ip->nlink < 1)
5694     panic("unlink: nlink < 1");
5695   if(ip->type == T_DIR && !isdirempty(ip)){
5696     iunlockput(ip);
5697     goto bad;
5698   }
5699 
5700   memset(&de, 0, sizeof(de));
5701   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5702     panic("unlink: writei");
5703   if(ip->type == T_DIR){
5704     dp->nlink--;
5705     iupdate(dp);
5706   }
5707   iunlockput(dp);
5708 
5709   ip->nlink--;
5710   iupdate(ip);
5711   iunlockput(ip);
5712 
5713   end_op();
5714 
5715   return 0;
5716 
5717 bad:
5718   iunlockput(dp);
5719   end_op();
5720   return -1;
5721 }
5722 
5723 static struct inode*
5724 create(char *path, short type, short major, short minor)
5725 {
5726   struct inode *ip, *dp;
5727   char name[DIRSIZ];
5728 
5729   if((dp = nameiparent(path, name)) == 0)
5730     return 0;
5731   ilock(dp);
5732 
5733   if((ip = dirlookup(dp, name, 0)) != 0){
5734     iunlockput(dp);
5735     ilock(ip);
5736     if(type == T_FILE && ip->type == T_FILE)
5737       return ip;
5738     iunlockput(ip);
5739     return 0;
5740   }
5741 
5742   if((ip = ialloc(dp->dev, type)) == 0)
5743     panic("create: ialloc");
5744 
5745   ilock(ip);
5746   ip->major = major;
5747   ip->minor = minor;
5748   ip->nlink = 1;
5749   iupdate(ip);
5750   if(type == T_DIR){  
5751     dp->nlink++;  
5752     iupdate(dp);
5753     
5754     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
5755       panic("create dots");
5756   }
5757 
5758   if(dirlink(dp, name, ip->inum) < 0)
5759     panic("create: dirlink");
5760 
5761   iunlockput(dp);
5762 
5763   return ip;
5764 }
5765 
5766 int
5767 sys_open(void)
5768 {
5769   char *path;
5770   int fd, omode;
5771   struct file *f;
5772   struct inode *ip;
5773 
5774   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
5775     return -1;
5776 
5777   begin_op();
5778 
5779   if(omode & O_CREATE){
5780     ip = create(path, T_FILE, 0, 0);
5781     if(ip == 0){
5782       end_op();
5783       return -1;
5784     }
5785   } else {
5786     if((ip = namei(path)) == 0){
5787       end_op();
5788       return -1;
5789     }
5790     ilock(ip);
5791     if(ip->type == T_DIR && omode != O_RDONLY){
5792       iunlockput(ip);
5793       end_op();
5794       return -1;
5795     }
5796   }
5797 
5798 
5799 
5800   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
5801     if(f)
5802       fileclose(f);
5803     iunlockput(ip);
5804     end_op();
5805     return -1;
5806   }
5807   iunlock(ip);
5808   end_op();
5809 
5810   f->type = FD_INODE;
5811   f->ip = ip;
5812   f->off = 0;
5813   f->readable = !(omode & O_WRONLY);
5814   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
5815   return fd;
5816 }
5817 
5818 int
5819 sys_mkdir(void)
5820 {
5821   char *path;
5822   struct inode *ip;
5823 
5824   begin_op();
5825   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
5826     end_op();
5827     return -1;
5828   }
5829   iunlockput(ip);
5830   end_op();
5831   return 0;
5832 }
5833 
5834 int
5835 sys_mknod(void)
5836 {
5837   struct inode *ip;
5838   char *path;
5839   int major, minor;
5840 
5841   begin_op();
5842   if((argstr(0, &path)) < 0 ||
5843      argint(1, &major) < 0 ||
5844      argint(2, &minor) < 0 ||
5845      (ip = create(path, T_DEV, major, minor)) == 0){
5846     end_op();
5847     return -1;
5848   }
5849   iunlockput(ip);
5850   end_op();
5851   return 0;
5852 }
5853 
5854 int
5855 sys_chdir(void)
5856 {
5857   char *path;
5858   struct inode *ip;
5859   struct proc *curproc = myproc();
5860 
5861   begin_op();
5862   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
5863     end_op();
5864     return -1;
5865   }
5866   ilock(ip);
5867   if(ip->type != T_DIR){
5868     iunlockput(ip);
5869     end_op();
5870     return -1;
5871   }
5872   iunlock(ip);
5873   iput(curproc->cwd);
5874   end_op();
5875   curproc->cwd = ip;
5876   return 0;
5877 }
5878 
5879 int
5880 sys_exec(void)
5881 {
5882   char *path, *argv[MAXARG];
5883   int i;
5884   uint uargv, uarg;
5885 
5886   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
5887     return -1;
5888   }
5889   memset(argv, 0, sizeof(argv));
5890   for(i=0;; i++){
5891     if(i >= NELEM(argv))
5892       return -1;
5893     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
5894       return -1;
5895     if(uarg == 0){
5896       argv[i] = 0;
5897       break;
5898     }
5899     if(fetchstr(uarg, &argv[i]) < 0)
5900       return -1;
5901   }
5902   return exec(path, argv);
5903 }
5904 
5905 int
5906 sys_pipe(void)
5907 {
5908   int *fd;
5909   struct file *rf, *wf;
5910   int fd0, fd1;
5911 
5912   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
5913     return -1;
5914   if(pipealloc(&rf, &wf) < 0)
5915     return -1;
5916   fd0 = -1;
5917   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
5918     if(fd0 >= 0)
5919       myproc()->ofile[fd0] = 0;
5920     fileclose(rf);
5921     fileclose(wf);
5922     return -1;
5923   }
5924   fd[0] = fd0;
5925   fd[1] = fd1;
5926   return 0;
5927 }
5928 
5929 
5930 
5931 
5932 
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 #include "types.h"
5951 #include "param.h"
5952 #include "memlayout.h"
5953 #include "mmu.h"
5954 #include "proc.h"
5955 #include "defs.h"
5956 #include "x86.h"
5957 #include "elf.h"
5958 
5959 int
5960 exec(char *path, char **argv)
5961 {
5962   char *s, *last;
5963   int i, off;
5964   uint argc, sz, sp, ustack[3+MAXARG+1];
5965   struct elfhdr elf;
5966   struct inode *ip;
5967   struct proghdr ph;
5968   pde_t *pgdir, *oldpgdir;
5969   struct proc *curproc = myproc();
5970 
5971   begin_op();
5972 
5973   if((ip = namei(path)) == 0){
5974     end_op();
5975     cprintf("exec: fail\n");
5976     return -1;
5977   }
5978   ilock(ip);
5979   pgdir = 0;
5980 
5981   
5982   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
5983     goto bad;
5984   if(elf.magic != ELF_MAGIC)
5985     goto bad;
5986 
5987   if((pgdir = setupkvm()) == 0)
5988     goto bad;
5989 
5990   
5991   sz = 0;
5992   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
5993     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
5994       goto bad;
5995     if(ph.type != ELF_PROG_LOAD)
5996       continue;
5997     if(ph.memsz < ph.filesz)
5998       goto bad;
5999     if(ph.vaddr + ph.memsz < ph.vaddr)
6000       goto bad;
6001     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6002       goto bad;
6003     if(ph.vaddr % PGSIZE != 0)
6004       goto bad;
6005     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6006       goto bad;
6007   }
6008   iunlockput(ip);
6009   end_op();
6010   ip = 0;
6011 
6012   
6013   
6014   sz = PGROUNDUP(sz);
6015   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6016     goto bad;
6017   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6018   sp = sz;
6019 
6020   
6021   for(argc = 0; argv[argc]; argc++) {
6022     if(argc >= MAXARG)
6023       goto bad;
6024     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6025     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6026       goto bad;
6027     ustack[3+argc] = sp;
6028   }
6029   ustack[3+argc] = 0;
6030 
6031   ustack[0] = 0xffffffff;  
6032   ustack[1] = argc;
6033   ustack[2] = sp - (argc+1)*4;  
6034 
6035   sp -= (3+argc+1) * 4;
6036   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6037     goto bad;
6038 
6039   
6040   for(last=s=path; *s; s++)
6041     if(*s == '/')
6042       last = s+1;
6043   safestrcpy(curproc->name, last, sizeof(curproc->name));
6044 
6045   
6046   oldpgdir = curproc->pgdir;
6047   curproc->pgdir = pgdir;
6048   curproc->sz = sz;
6049   curproc->tf->eip = elf.entry;  
6050   curproc->tf->esp = sp;
6051   switchuvm(curproc);
6052   freevm(oldpgdir);
6053   return 0;
6054 
6055  bad:
6056   if(pgdir)
6057     freevm(pgdir);
6058   if(ip){
6059     iunlockput(ip);
6060     end_op();
6061   }
6062   return -1;
6063 }
6064 
6065 
6066 
6067 
6068 
6069 
6070 
6071 
6072 
6073 
6074 
6075 
6076 
6077 
6078 
6079 
6080 
6081 
6082 
6083 
6084 
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 #include "types.h"
6101 #include "defs.h"
6102 #include "param.h"
6103 #include "mmu.h"
6104 #include "proc.h"
6105 #include "fs.h"
6106 #include "spinlock.h"
6107 #include "sleeplock.h"
6108 #include "file.h"
6109 
6110 #define PIPESIZE 512
6111 
6112 struct pipe {
6113   struct spinlock lock;
6114   char data[PIPESIZE];
6115   uint nread;     
6116   uint nwrite;    
6117   int readopen;   
6118   int writeopen;  
6119 };
6120 
6121 int
6122 pipealloc(struct file **f0, struct file **f1)
6123 {
6124   struct pipe *p;
6125 
6126   p = 0;
6127   *f0 = *f1 = 0;
6128   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6129     goto bad;
6130   if((p = (struct pipe*)kalloc()) == 0)
6131     goto bad;
6132   p->readopen = 1;
6133   p->writeopen = 1;
6134   p->nwrite = 0;
6135   p->nread = 0;
6136   initlock(&p->lock, "pipe");
6137   (*f0)->type = FD_PIPE;
6138   (*f0)->readable = 1;
6139   (*f0)->writable = 0;
6140   (*f0)->pipe = p;
6141   (*f1)->type = FD_PIPE;
6142   (*f1)->readable = 0;
6143   (*f1)->writable = 1;
6144   (*f1)->pipe = p;
6145   return 0;
6146 
6147 
6148 
6149 
6150  bad:
6151   if(p)
6152     kfree((char*)p);
6153   if(*f0)
6154     fileclose(*f0);
6155   if(*f1)
6156     fileclose(*f1);
6157   return -1;
6158 }
6159 
6160 void
6161 pipeclose(struct pipe *p, int writable)
6162 {
6163   acquire(&p->lock);
6164   if(writable){
6165     p->writeopen = 0;
6166     wakeup(&p->nread);
6167   } else {
6168     p->readopen = 0;
6169     wakeup(&p->nwrite);
6170   }
6171   if(p->readopen == 0 && p->writeopen == 0){
6172     release(&p->lock);
6173     kfree((char*)p);
6174   } else
6175     release(&p->lock);
6176 }
6177 
6178 int
6179 pipewrite(struct pipe *p, char *addr, int n)
6180 {
6181   int i;
6182 
6183   acquire(&p->lock);
6184   for(i = 0; i < n; i++){
6185     while(p->nwrite == p->nread + PIPESIZE){  
6186       if(p->readopen == 0 || myproc()->killed){
6187         release(&p->lock);
6188         return -1;
6189       }
6190       wakeup(&p->nread);
6191       sleep(&p->nwrite, &p->lock);  
6192     }
6193     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6194   }
6195   wakeup(&p->nread);  
6196   release(&p->lock);
6197   return n;
6198 }
6199 
6200 int
6201 piperead(struct pipe *p, char *addr, int n)
6202 {
6203   int i;
6204 
6205   acquire(&p->lock);
6206   while(p->nread == p->nwrite && p->writeopen){  
6207     if(myproc()->killed){
6208       release(&p->lock);
6209       return -1;
6210     }
6211     sleep(&p->nread, &p->lock); 
6212   }
6213   for(i = 0; i < n; i++){  
6214     if(p->nread == p->nwrite)
6215       break;
6216     addr[i] = p->data[p->nread++ % PIPESIZE];
6217   }
6218   wakeup(&p->nwrite);  
6219   release(&p->lock);
6220   return i;
6221 }
6222 
6223 
6224 
6225 
6226 
6227 
6228 
6229 
6230 
6231 
6232 
6233 
6234 
6235 
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 #include "types.h"
6251 #include "x86.h"
6252 
6253 void*
6254 memset(void *dst, int c, uint n)
6255 {
6256   if ((int)dst%4 == 0 && n%4 == 0){
6257     c &= 0xFF;
6258     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6259   } else
6260     stosb(dst, c, n);
6261   return dst;
6262 }
6263 
6264 int
6265 memcmp(const void *v1, const void *v2, uint n)
6266 {
6267   const uchar *s1, *s2;
6268 
6269   s1 = v1;
6270   s2 = v2;
6271   while(n-- > 0){
6272     if(*s1 != *s2)
6273       return *s1 - *s2;
6274     s1++, s2++;
6275   }
6276 
6277   return 0;
6278 }
6279 
6280 void*
6281 memmove(void *dst, const void *src, uint n)
6282 {
6283   const char *s;
6284   char *d;
6285 
6286   s = src;
6287   d = dst;
6288   if(s < d && s + n > d){
6289     s += n;
6290     d += n;
6291     while(n-- > 0)
6292       *--d = *--s;
6293   } else
6294     while(n-- > 0)
6295       *d++ = *s++;
6296 
6297   return dst;
6298 }
6299 
6300 
6301 void*
6302 memcpy(void *dst, const void *src, uint n)
6303 {
6304   return memmove(dst, src, n);
6305 }
6306 
6307 int
6308 strncmp(const char *p, const char *q, uint n)
6309 {
6310   while(n > 0 && *p && *p == *q)
6311     n--, p++, q++;
6312   if(n == 0)
6313     return 0;
6314   return (uchar)*p - (uchar)*q;
6315 }
6316 
6317 char*
6318 strncpy(char *s, const char *t, int n)
6319 {
6320   char *os;
6321 
6322   os = s;
6323   while(n-- > 0 && (*s++ = *t++) != 0)
6324     ;
6325   while(n-- > 0)
6326     *s++ = 0;
6327   return os;
6328 }
6329 
6330 
6331 char*
6332 safestrcpy(char *s, const char *t, int n)
6333 {
6334   char *os;
6335 
6336   os = s;
6337   if(n <= 0)
6338     return os;
6339   while(--n > 0 && (*s++ = *t++) != 0)
6340     ;
6341   *s = 0;
6342   return os;
6343 }
6344 
6345 
6346 
6347 
6348 
6349 
6350 int
6351 strlen(const char *s)
6352 {
6353   int n;
6354 
6355   for(n = 0; s[n]; n++)
6356     ;
6357   return n;
6358 }
6359 
6360 
6361 
6362 
6363 
6364 
6365 
6366 
6367 
6368 
6369 
6370 
6371 
6372 
6373 
6374 
6375 
6376 
6377 
6378 
6379 
6380 
6381 
6382 
6383 
6384 
6385 
6386 
6387 
6388 
6389 
6390 
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 
6401 
6402 struct mp {             
6403   uchar signature[4];           
6404   void *physaddr;               
6405   uchar length;                 
6406   uchar specrev;                
6407   uchar checksum;               
6408   uchar type;                   
6409   uchar imcrp;
6410   uchar reserved[3];
6411 };
6412 
6413 struct mpconf {         
6414   uchar signature[4];           
6415   ushort length;                
6416   uchar version;                
6417   uchar checksum;               
6418   uchar product[20];            
6419   uint *oemtable;               
6420   ushort oemlength;             
6421   ushort entry;                 
6422   uint *lapicaddr;              
6423   ushort xlength;               
6424   uchar xchecksum;              
6425   uchar reserved;
6426 };
6427 
6428 struct mpproc {         
6429   uchar type;                   
6430   uchar apicid;                 
6431   uchar version;                
6432   uchar flags;                  
6433     #define MPBOOT 0x02           
6434   uchar signature[4];           
6435   uint feature;                 
6436   uchar reserved[8];
6437 };
6438 
6439 struct mpioapic {       
6440   uchar type;                   
6441   uchar apicno;                 
6442   uchar version;                
6443   uchar flags;                  
6444   uint *addr;                  
6445 };
6446 
6447 
6448 
6449 
6450 
6451 #define MPPROC    0x00  
6452 #define MPBUS     0x01  
6453 #define MPIOAPIC  0x02  
6454 #define MPIOINTR  0x03  
6455 #define MPLINTR   0x04  
6456 
6457 
6458 
6459 
6460 
6461 
6462 
6463 
6464 
6465 
6466 
6467 
6468 
6469 
6470 
6471 
6472 
6473 
6474 
6475 
6476 
6477 
6478 
6479 
6480 
6481 
6482 
6483 
6484 
6485 
6486 
6487 
6488 
6489 
6490 
6491 
6492 
6493 
6494 
6495 
6496 
6497 
6498 
6499 
6500 
6501 
6502 
6503 
6504 #include "types.h"
6505 #include "defs.h"
6506 #include "param.h"
6507 #include "memlayout.h"
6508 #include "mp.h"
6509 #include "x86.h"
6510 #include "mmu.h"
6511 #include "proc.h"
6512 
6513 struct cpu cpus[NCPU];
6514 int ncpu;
6515 uchar ioapicid;
6516 
6517 static uchar
6518 sum(uchar *addr, int len)
6519 {
6520   int i, sum;
6521 
6522   sum = 0;
6523   for(i=0; i<len; i++)
6524     sum += addr[i];
6525   return sum;
6526 }
6527 
6528 
6529 static struct mp*
6530 mpsearch1(uint a, int len)
6531 {
6532   uchar *e, *p, *addr;
6533 
6534   addr = P2V(a);
6535   e = addr+len;
6536   for(p = addr; p < e; p += sizeof(struct mp))
6537     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
6538       return (struct mp*)p;
6539   return 0;
6540 }
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 
6551 
6552 
6553 
6554 
6555 static struct mp*
6556 mpsearch(void)
6557 {
6558   uchar *bda;
6559   uint p;
6560   struct mp *mp;
6561 
6562   bda = (uchar *) P2V(0x400);
6563   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
6564     if((mp = mpsearch1(p, 1024)))
6565       return mp;
6566   } else {
6567     p = ((bda[0x14]<<8)|bda[0x13])*1024;
6568     if((mp = mpsearch1(p-1024, 1024)))
6569       return mp;
6570   }
6571   return mpsearch1(0xF0000, 0x10000);
6572 }
6573 
6574 
6575 
6576 
6577 
6578 
6579 static struct mpconf*
6580 mpconfig(struct mp **pmp)
6581 {
6582   struct mpconf *conf;
6583   struct mp *mp;
6584 
6585   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
6586     return 0;
6587   conf = (struct mpconf*) P2V((uint) mp->physaddr);
6588   if(memcmp(conf, "PCMP", 4) != 0)
6589     return 0;
6590   if(conf->version != 1 && conf->version != 4)
6591     return 0;
6592   if(sum((uchar*)conf, conf->length) != 0)
6593     return 0;
6594   *pmp = mp;
6595   return conf;
6596 }
6597 
6598 
6599 
6600 void
6601 mpinit(void)
6602 {
6603   uchar *p, *e;
6604   int ismp;
6605   struct mp *mp;
6606   struct mpconf *conf;
6607   struct mpproc *proc;
6608   struct mpioapic *ioapic;
6609 
6610   if((conf = mpconfig(&mp)) == 0)
6611     panic("Expect to run on an SMP");
6612   ismp = 1;
6613   lapic = (uint*)conf->lapicaddr;
6614   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
6615     switch(*p){
6616     case MPPROC:
6617       proc = (struct mpproc*)p;
6618       if(ncpu < NCPU) {
6619         cpus[ncpu].apicid = proc->apicid;  
6620         ncpu++;
6621       }
6622       p += sizeof(struct mpproc);
6623       continue;
6624     case MPIOAPIC:
6625       ioapic = (struct mpioapic*)p;
6626       ioapicid = ioapic->apicno;
6627       p += sizeof(struct mpioapic);
6628       continue;
6629     case MPBUS:
6630     case MPIOINTR:
6631     case MPLINTR:
6632       p += 8;
6633       continue;
6634     default:
6635       ismp = 0;
6636       break;
6637     }
6638   }
6639   if(!ismp)
6640     panic("Didn't find a suitable machine");
6641 
6642   if(mp->imcrp){
6643     
6644     
6645     outb(0x22, 0x70);   
6646     outb(0x23, inb(0x23) | 1);  
6647   }
6648 }
6649 
6650 
6651 
6652 
6653 #include "param.h"
6654 #include "types.h"
6655 #include "defs.h"
6656 #include "date.h"
6657 #include "memlayout.h"
6658 #include "traps.h"
6659 #include "mmu.h"
6660 #include "x86.h"
6661 
6662 
6663 #define ID      (0x0020/4)   
6664 #define VER     (0x0030/4)   
6665 #define TPR     (0x0080/4)   
6666 #define EOI     (0x00B0/4)   
6667 #define SVR     (0x00F0/4)   
6668   #define ENABLE     0x00000100   
6669 #define ESR     (0x0280/4)   
6670 #define ICRLO   (0x0300/4)   
6671   #define INIT       0x00000500   
6672   #define STARTUP    0x00000600   
6673   #define DELIVS     0x00001000   
6674   #define ASSERT     0x00004000   
6675   #define DEASSERT   0x00000000
6676   #define LEVEL      0x00008000   
6677   #define BCAST      0x00080000   
6678   #define BUSY       0x00001000
6679   #define FIXED      0x00000000
6680 #define ICRHI   (0x0310/4)   
6681 #define TIMER   (0x0320/4)   
6682   #define X1         0x0000000B   
6683   #define PERIODIC   0x00020000   
6684 #define PCINT   (0x0340/4)   
6685 #define LINT0   (0x0350/4)   
6686 #define LINT1   (0x0360/4)   
6687 #define ERROR   (0x0370/4)   
6688   #define MASKED     0x00010000   
6689 #define TICR    (0x0380/4)   
6690 #define TCCR    (0x0390/4)   
6691 #define TDCR    (0x03E0/4)   
6692 
6693 volatile uint *lapic;  
6694 
6695 static void
6696 lapicw(int index, int value)
6697 {
6698   lapic[index] = value;
6699   lapic[ID];  
6700 }
6701 
6702 void
6703 lapicinit(void)
6704 {
6705   if(!lapic)
6706     return;
6707 
6708   
6709   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
6710 
6711   
6712   
6713   
6714   
6715   lapicw(TDCR, X1);
6716   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
6717   lapicw(TICR, 10000000);
6718 
6719   
6720   lapicw(LINT0, MASKED);
6721   lapicw(LINT1, MASKED);
6722 
6723   
6724   
6725   if(((lapic[VER]>>16) & 0xFF) >= 4)
6726     lapicw(PCINT, MASKED);
6727 
6728   
6729   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
6730 
6731   
6732   lapicw(ESR, 0);
6733   lapicw(ESR, 0);
6734 
6735   
6736   lapicw(EOI, 0);
6737 
6738   
6739   lapicw(ICRHI, 0);
6740   lapicw(ICRLO, BCAST | INIT | LEVEL);
6741   while(lapic[ICRLO] & DELIVS)
6742     ;
6743 
6744   
6745   lapicw(TPR, 0);
6746 }
6747 
6748 
6749 
6750 int
6751 lapicid(void)
6752 {
6753   if (!lapic)
6754     return 0;
6755   return lapic[ID] >> 24;
6756 }
6757 
6758 
6759 void
6760 lapiceoi(void)
6761 {
6762   if(lapic)
6763     lapicw(EOI, 0);
6764 }
6765 
6766 
6767 
6768 void
6769 microdelay(int us)
6770 {
6771 }
6772 
6773 #define CMOS_PORT    0x70
6774 #define CMOS_RETURN  0x71
6775 
6776 
6777 
6778 void
6779 lapicstartap(uchar apicid, uint addr)
6780 {
6781   int i;
6782   ushort *wrv;
6783 
6784   
6785   
6786   
6787   outb(CMOS_PORT, 0xF);  
6788   outb(CMOS_PORT+1, 0x0A);
6789   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
6790   wrv[0] = 0;
6791   wrv[1] = addr >> 4;
6792 
6793   
6794   
6795   lapicw(ICRHI, apicid<<24);
6796   lapicw(ICRLO, INIT | LEVEL | ASSERT);
6797   microdelay(200);
6798   lapicw(ICRLO, INIT | LEVEL);
6799   microdelay(100);    
6800   
6801   
6802   
6803   
6804   
6805   for(i = 0; i < 2; i++){
6806     lapicw(ICRHI, apicid<<24);
6807     lapicw(ICRLO, STARTUP | (addr>>12));
6808     microdelay(200);
6809   }
6810 }
6811 
6812 #define CMOS_STATA   0x0a
6813 #define CMOS_STATB   0x0b
6814 #define CMOS_UIP    (1 << 7)        
6815 
6816 #define SECS    0x00
6817 #define MINS    0x02
6818 #define HOURS   0x04
6819 #define DAY     0x07
6820 #define MONTH   0x08
6821 #define YEAR    0x09
6822 
6823 static uint
6824 cmos_read(uint reg)
6825 {
6826   outb(CMOS_PORT,  reg);
6827   microdelay(200);
6828 
6829   return inb(CMOS_RETURN);
6830 }
6831 
6832 static void
6833 fill_rtcdate(struct rtcdate *r)
6834 {
6835   r->second = cmos_read(SECS);
6836   r->minute = cmos_read(MINS);
6837   r->hour   = cmos_read(HOURS);
6838   r->day    = cmos_read(DAY);
6839   r->month  = cmos_read(MONTH);
6840   r->year   = cmos_read(YEAR);
6841 }
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 
6851 void
6852 cmostime(struct rtcdate *r)
6853 {
6854   struct rtcdate t1, t2;
6855   int sb, bcd;
6856 
6857   sb = cmos_read(CMOS_STATB);
6858 
6859   bcd = (sb & (1 << 2)) == 0;
6860 
6861   
6862   for(;;) {
6863     fill_rtcdate(&t1);
6864     if(cmos_read(CMOS_STATA) & CMOS_UIP)
6865         continue;
6866     fill_rtcdate(&t2);
6867     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
6868       break;
6869   }
6870 
6871   
6872   if(bcd) {
6873 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
6874     CONV(second);
6875     CONV(minute);
6876     CONV(hour  );
6877     CONV(day   );
6878     CONV(month );
6879     CONV(year  );
6880 #undef     CONV
6881   }
6882 
6883   *r = t1;
6884   r->year += 2000;
6885 }
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 
6901 
6902 
6903 
6904 #include "types.h"
6905 #include "defs.h"
6906 #include "traps.h"
6907 
6908 #define IOAPIC  0xFEC00000   
6909 
6910 #define REG_ID     0x00  
6911 #define REG_VER    0x01  
6912 #define REG_TABLE  0x10  
6913 
6914 
6915 
6916 
6917 
6918 
6919 #define INT_DISABLED   0x00010000  
6920 #define INT_LEVEL      0x00008000  
6921 #define INT_ACTIVELOW  0x00002000  
6922 #define INT_LOGICAL    0x00000800  
6923 
6924 volatile struct ioapic *ioapic;
6925 
6926 
6927 struct ioapic {
6928   uint reg;
6929   uint pad[3];
6930   uint data;
6931 };
6932 
6933 static uint
6934 ioapicread(int reg)
6935 {
6936   ioapic->reg = reg;
6937   return ioapic->data;
6938 }
6939 
6940 static void
6941 ioapicwrite(int reg, uint data)
6942 {
6943   ioapic->reg = reg;
6944   ioapic->data = data;
6945 }
6946 
6947 
6948 
6949 
6950 void
6951 ioapicinit(void)
6952 {
6953   int i, id, maxintr;
6954 
6955   ioapic = (volatile struct ioapic*)IOAPIC;
6956   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
6957   id = ioapicread(REG_ID) >> 24;
6958   if(id != ioapicid)
6959     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
6960 
6961   
6962   
6963   for(i = 0; i <= maxintr; i++){
6964     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
6965     ioapicwrite(REG_TABLE+2*i+1, 0);
6966   }
6967 }
6968 
6969 void
6970 ioapicenable(int irq, int cpunum)
6971 {
6972   
6973   
6974   
6975   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
6976   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
6977 }
6978 
6979 
6980 
6981 
6982 
6983 
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 
7001 
7002 #define KBSTATP         0x64    
7003 #define KBS_DIB         0x01    
7004 #define KBDATAP         0x60    
7005 
7006 #define NO              0
7007 
7008 #define SHIFT           (1<<0)
7009 #define CTL             (1<<1)
7010 #define ALT             (1<<2)
7011 
7012 #define CAPSLOCK        (1<<3)
7013 #define NUMLOCK         (1<<4)
7014 #define SCROLLLOCK      (1<<5)
7015 
7016 #define E0ESC           (1<<6)
7017 
7018 
7019 #define KEY_HOME        0xE0
7020 #define KEY_END         0xE1
7021 #define KEY_UP          0xE2
7022 #define KEY_DN          0xE3
7023 #define KEY_LF          0xE4
7024 #define KEY_RT          0xE5
7025 #define KEY_PGUP        0xE6
7026 #define KEY_PGDN        0xE7
7027 #define KEY_INS         0xE8
7028 #define KEY_DEL         0xE9
7029 
7030 
7031 #define C(x) (x - '@')
7032 
7033 static uchar shiftcode[256] =
7034 {
7035   [0x1D] CTL,
7036   [0x2A] SHIFT,
7037   [0x36] SHIFT,
7038   [0x38] ALT,
7039   [0x9D] CTL,
7040   [0xB8] ALT
7041 };
7042 
7043 static uchar togglecode[256] =
7044 {
7045   [0x3A] CAPSLOCK,
7046   [0x45] NUMLOCK,
7047   [0x46] SCROLLLOCK
7048 };
7049 
7050 static uchar normalmap[256] =
7051 {
7052   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7053   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7054   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7055   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7056   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7057   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7058   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7059   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7060   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7061   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7062   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7063   [0x9C] '\n',      
7064   [0xB5] '/',       
7065   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7066   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7067   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7068   [0x97] KEY_HOME,  [0xCF] KEY_END,
7069   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7070 };
7071 
7072 static uchar shiftmap[256] =
7073 {
7074   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7075   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7076   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7077   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7078   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7079   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7080   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7081   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7082   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7083   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7084   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7085   [0x9C] '\n',      
7086   [0xB5] '/',       
7087   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7088   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7089   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7090   [0x97] KEY_HOME,  [0xCF] KEY_END,
7091   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7092 };
7093 
7094 
7095 
7096 
7097 
7098 
7099 
7100 static uchar ctlmap[256] =
7101 {
7102   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7103   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7104   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7105   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7106   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7107   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7108   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7109   [0x9C] '\r',      
7110   [0xB5] C('/'),    
7111   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7112   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7113   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7114   [0x97] KEY_HOME,  [0xCF] KEY_END,
7115   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7116 };
7117 
7118 
7119 
7120 
7121 
7122 
7123 
7124 
7125 
7126 
7127 
7128 
7129 
7130 
7131 
7132 
7133 
7134 
7135 
7136 
7137 
7138 
7139 
7140 
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 #include "types.h"
7151 #include "x86.h"
7152 #include "defs.h"
7153 #include "kbd.h"
7154 
7155 int
7156 kbdgetc(void)
7157 {
7158   static uint shift;
7159   static uchar *charcode[4] = {
7160     normalmap, shiftmap, ctlmap, ctlmap
7161   };
7162   uint st, data, c;
7163 
7164   st = inb(KBSTATP);
7165   if((st & KBS_DIB) == 0)
7166     return -1;
7167   data = inb(KBDATAP);
7168 
7169   if(data == 0xE0){
7170     shift |= E0ESC;
7171     return 0;
7172   } else if(data & 0x80){
7173     
7174     data = (shift & E0ESC ? data : data & 0x7F);
7175     shift &= ~(shiftcode[data] | E0ESC);
7176     return 0;
7177   } else if(shift & E0ESC){
7178     
7179     data |= 0x80;
7180     shift &= ~E0ESC;
7181   }
7182 
7183   shift |= shiftcode[data];
7184   shift ^= togglecode[data];
7185   c = charcode[shift & (CTL | SHIFT)][data];
7186   if(shift & CAPSLOCK){
7187     if('a' <= c && c <= 'z')
7188       c += 'A' - 'a';
7189     else if('A' <= c && c <= 'Z')
7190       c += 'a' - 'A';
7191   }
7192   return c;
7193 }
7194 
7195 void
7196 kbdintr(void)
7197 {
7198   consoleintr(kbdgetc);
7199 }
7200 
7201 
7202 
7203 
7204 #include "types.h"
7205 #include "defs.h"
7206 #include "param.h"
7207 #include "traps.h"
7208 #include "spinlock.h"
7209 #include "sleeplock.h"
7210 #include "fs.h"
7211 #include "file.h"
7212 #include "memlayout.h"
7213 #include "mmu.h"
7214 #include "proc.h"
7215 #include "x86.h"
7216 
7217 static void consputc(int);
7218 
7219 static int panicked = 0;
7220 
7221 static struct {
7222   struct spinlock lock;
7223   int locking;
7224 } cons;
7225 
7226 static void
7227 printint(int xx, int base, int sign)
7228 {
7229   static char digits[] = "0123456789abcdef";
7230   char buf[16];
7231   int i;
7232   uint x;
7233 
7234   if(sign && (sign = xx < 0))
7235     x = -xx;
7236   else
7237     x = xx;
7238 
7239   i = 0;
7240   do{
7241     buf[i++] = digits[x % base];
7242   }while((x /= base) != 0);
7243 
7244   if(sign)
7245     buf[i++] = '-';
7246 
7247   while(--i >= 0)
7248     consputc(buf[i]);
7249 }
7250 
7251 void
7252 cprintf(char *fmt, ...)
7253 {
7254   int i, c, locking;
7255   uint *argp;
7256   char *s;
7257 
7258   locking = cons.locking;
7259   if(locking)
7260     acquire(&cons.lock);
7261 
7262   if (fmt == 0)
7263     panic("null fmt");
7264 
7265   argp = (uint*)(void*)(&fmt + 1);
7266   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7267     if(c != '%'){
7268       consputc(c);
7269       continue;
7270     }
7271     c = fmt[++i] & 0xff;
7272     if(c == 0)
7273       break;
7274     switch(c){
7275     case 'd':
7276       printint(*argp++, 10, 1);
7277       break;
7278     case 'x':
7279     case 'p':
7280       printint(*argp++, 16, 0);
7281       break;
7282     case 's':
7283       if((s = (char*)*argp++) == 0)
7284         s = "(null)";
7285       for(; *s; s++)
7286         consputc(*s);
7287       break;
7288     case '%':
7289       consputc('%');
7290       break;
7291     default:
7292       
7293       consputc('%');
7294       consputc(c);
7295       break;
7296     }
7297   }
7298 
7299 
7300   if(locking)
7301     release(&cons.lock);
7302 }
7303 
7304 void
7305 panic(char *s)
7306 {
7307   int i;
7308   uint pcs[10];
7309 
7310   cli();
7311   cons.locking = 0;
7312   
7313   cprintf("lapicid %d: panic: ", lapicid());
7314   cprintf(s);
7315   cprintf("\n");
7316   getcallerpcs(&s, pcs);
7317   for(i=0; i<10; i++)
7318     cprintf(" %p", pcs[i]);
7319   panicked = 1; 
7320   for(;;)
7321     ;
7322 }
7323 
7324 #define BACKSPACE 0x100
7325 #define CRTPORT 0x3d4
7326 static ushort *crt = (ushort*)P2V(0xb8000);  
7327 
7328 static void
7329 cgaputc(int c)
7330 {
7331   int pos;
7332 
7333   
7334   outb(CRTPORT, 14);
7335   pos = inb(CRTPORT+1) << 8;
7336   outb(CRTPORT, 15);
7337   pos |= inb(CRTPORT+1);
7338 
7339   if(c == '\n')
7340     pos += 80 - pos%80;
7341   else if(c == BACKSPACE){
7342     if(pos > 0) --pos;
7343   } else
7344     crt[pos++] = (c&0xff) | 0x0700;  
7345 
7346   if(pos < 0 || pos > 25*80)
7347     panic("pos under/overflow");
7348 
7349 
7350   if((pos/80) >= 24){  
7351     memmove(crt, crt+80, sizeof(crt[0])*23*80);
7352     pos -= 80;
7353     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
7354   }
7355 
7356   outb(CRTPORT, 14);
7357   outb(CRTPORT+1, pos>>8);
7358   outb(CRTPORT, 15);
7359   outb(CRTPORT+1, pos);
7360   crt[pos] = ' ' | 0x0700;
7361 }
7362 
7363 void
7364 consputc(int c)
7365 {
7366   if(panicked){
7367     cli();
7368     for(;;)
7369       ;
7370   }
7371 
7372   if(c == BACKSPACE){
7373     uartputc('\b'); uartputc(' '); uartputc('\b');
7374   } else
7375     uartputc(c);
7376   cgaputc(c);
7377 }
7378 
7379 #define INPUT_BUF 128
7380 struct {
7381   char buf[INPUT_BUF];
7382   uint r;  
7383   uint w;  
7384   uint e;  
7385 } input;
7386 
7387 #define C(x)  ((x)-'@')  
7388 
7389 void
7390 consoleintr(int (*getc)(void))
7391 {
7392   int c, doprocdump = 0;
7393 
7394   acquire(&cons.lock);
7395   while((c = getc()) >= 0){
7396     switch(c){
7397     case C('P'):  
7398       
7399       doprocdump = 1;
7400       break;
7401     case C('U'):  
7402       while(input.e != input.w &&
7403             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
7404         input.e--;
7405         consputc(BACKSPACE);
7406       }
7407       break;
7408     case C('H'): case '\x7f':  
7409       if(input.e != input.w){
7410         input.e--;
7411         consputc(BACKSPACE);
7412       }
7413       break;
7414     default:
7415       if(c != 0 && input.e-input.r < INPUT_BUF){
7416         c = (c == '\r') ? '\n' : c;
7417         input.buf[input.e++ % INPUT_BUF] = c;
7418         consputc(c);
7419         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
7420           input.w = input.e;
7421           wakeup(&input.r);
7422         }
7423       }
7424       break;
7425     }
7426   }
7427   release(&cons.lock);
7428   if(doprocdump) {
7429     procdump();  
7430   }
7431 }
7432 
7433 int
7434 consoleread(struct inode *ip, char *dst, int n)
7435 {
7436   uint target;
7437   int c;
7438 
7439   iunlock(ip);
7440   target = n;
7441   acquire(&cons.lock);
7442   while(n > 0){
7443     while(input.r == input.w){
7444       if(myproc()->killed){
7445         release(&cons.lock);
7446         ilock(ip);
7447         return -1;
7448       }
7449       sleep(&input.r, &cons.lock);
7450     }
7451     c = input.buf[input.r++ % INPUT_BUF];
7452     if(c == C('D')){  
7453       if(n < target){
7454         
7455         
7456         input.r--;
7457       }
7458       break;
7459     }
7460     *dst++ = c;
7461     --n;
7462     if(c == '\n')
7463       break;
7464   }
7465   release(&cons.lock);
7466   ilock(ip);
7467 
7468   return target - n;
7469 }
7470 
7471 int
7472 consolewrite(struct inode *ip, char *buf, int n)
7473 {
7474   int i;
7475 
7476   iunlock(ip);
7477   acquire(&cons.lock);
7478   for(i = 0; i < n; i++)
7479     consputc(buf[i] & 0xff);
7480   release(&cons.lock);
7481   ilock(ip);
7482 
7483   return n;
7484 }
7485 
7486 void
7487 consoleinit(void)
7488 {
7489   initlock(&cons.lock, "console");
7490 
7491   devsw[CONSOLE].write = consolewrite;
7492   devsw[CONSOLE].read = consoleread;
7493   cons.locking = 1;
7494 
7495   ioapicenable(IRQ_KBD, 0);
7496 }
7497 
7498 
7499 
7500 
7501 
7502 #include "types.h"
7503 #include "defs.h"
7504 #include "param.h"
7505 #include "traps.h"
7506 #include "spinlock.h"
7507 #include "sleeplock.h"
7508 #include "fs.h"
7509 #include "file.h"
7510 #include "mmu.h"
7511 #include "proc.h"
7512 #include "x86.h"
7513 
7514 #define COM1    0x3f8
7515 
7516 static int uart;    
7517 
7518 void
7519 uartinit(void)
7520 {
7521   char *p;
7522 
7523   
7524   outb(COM1+2, 0);
7525 
7526   
7527   outb(COM1+3, 0x80);    
7528   outb(COM1+0, 115200/9600);
7529   outb(COM1+1, 0);
7530   outb(COM1+3, 0x03);    
7531   outb(COM1+4, 0);
7532   outb(COM1+1, 0x01);    
7533 
7534   
7535   if(inb(COM1+5) == 0xFF)
7536     return;
7537   uart = 1;
7538 
7539   
7540   
7541   inb(COM1+2);
7542   inb(COM1+0);
7543   ioapicenable(IRQ_COM1, 0);
7544 
7545   
7546   for(p="xv6...\n"; *p; p++)
7547     uartputc(*p);
7548 }
7549 
7550 void
7551 uartputc(int c)
7552 {
7553   int i;
7554 
7555   if(!uart)
7556     return;
7557   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
7558     microdelay(10);
7559   outb(COM1+0, c);
7560 }
7561 
7562 static int
7563 uartgetc(void)
7564 {
7565   if(!uart)
7566     return -1;
7567   if(!(inb(COM1+5) & 0x01))
7568     return -1;
7569   return inb(COM1+0);
7570 }
7571 
7572 void
7573 uartintr(void)
7574 {
7575   consoleintr(uartgetc);
7576 }
7577 
7578 
7579 
7580 
7581 
7582 
7583 
7584 
7585 
7586 
7587 
7588 
7589 
7590 
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 
7601 
7602 
7603 
7604 
7605 
7606 
7607 
7608 .globl start
7609 start:
7610   pushl $argv
7611   pushl $init
7612   pushl $0  
7613   movl $SYS_exec, %eax
7614   int $T_SYSCALL
7615 
7616 
7617 exit:
7618   movl $SYS_exit, %eax
7619   int $T_SYSCALL
7620   jmp exit
7621 
7622 
7623 init:
7624   .string "/init\0"
7625 
7626 
7627 .p2align 2
7628 argv:
7629   .long init
7630   .long 0
7631 
7632 
7633 
7634 
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 
7651 
7652 
7653 
7654   .globl name; \
7655   name: \
7656     movl $SYS_ 
7657     int $T_SYSCALL; \
7658     ret
7659 
7660 SYSCALL(fork)
7661 SYSCALL(exit)
7662 SYSCALL(wait)
7663 SYSCALL(pipe)
7664 SYSCALL(read)
7665 SYSCALL(write)
7666 SYSCALL(close)
7667 SYSCALL(kill)
7668 SYSCALL(exec)
7669 SYSCALL(open)
7670 SYSCALL(mknod)
7671 SYSCALL(unlink)
7672 SYSCALL(fstat)
7673 SYSCALL(link)
7674 SYSCALL(mkdir)
7675 SYSCALL(chdir)
7676 SYSCALL(dup)
7677 SYSCALL(getpid)
7678 SYSCALL(sbrk)
7679 SYSCALL(sleep)
7680 SYSCALL(uptime)
7681 
7682 
7683 
7684 
7685 
7686 
7687 
7688 
7689 
7690 
7691 
7692 
7693 
7694 
7695 
7696 
7697 
7698 
7699 
7700 
7701 
7702 #include "types.h"
7703 #include "stat.h"
7704 #include "user.h"
7705 #include "fcntl.h"
7706 
7707 char *argv[] = { "sh", 0 };
7708 
7709 int
7710 main(void)
7711 {
7712   int pid, wpid;
7713 
7714   if(open("console", O_RDWR) < 0){
7715     mknod("console", 1, 1);
7716     open("console", O_RDWR);
7717   }
7718   dup(0);  
7719   dup(0);  
7720 
7721   for(;;){
7722     
7723     printf(1, "init: starting login\n");
7724     pid = fork();
7725     if(pid < 0){
7726       printf(1, "init: fork failed\n");
7727       exit();
7728     }
7729     if(pid == 0){
7730       exec("ssu_login",argv);
7731       
7732       
7733       printf(1, "init: exec ssu_login failed\n");
7734       exit();
7735     }
7736     while((wpid=wait()) >= 0 && wpid != pid)
7737       printf(1, "zombie!\n");
7738   }
7739 }
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 
7751 
7752 #include "types.h"
7753 #include "user.h"
7754 #include "fcntl.h"
7755 
7756 
7757 #define EXEC  1
7758 #define REDIR 2
7759 #define PIPE  3
7760 #define LIST  4
7761 #define BACK  5
7762 
7763 #define MAXARGS 10
7764 
7765 struct cmd {
7766   int type;
7767 };
7768 
7769 struct execcmd {
7770   int type;
7771   char *argv[MAXARGS];
7772   char *eargv[MAXARGS];
7773 };
7774 
7775 struct redircmd {
7776   int type;
7777   struct cmd *cmd;
7778   char *file;
7779   char *efile;
7780   int mode;
7781   int fd;
7782 };
7783 
7784 struct pipecmd {
7785   int type;
7786   struct cmd *left;
7787   struct cmd *right;
7788 };
7789 
7790 struct listcmd {
7791   int type;
7792   struct cmd *left;
7793   struct cmd *right;
7794 };
7795 
7796 struct backcmd {
7797   int type;
7798   struct cmd *cmd;
7799 };
7800 int fork1(void);  
7801 void panic(char*);
7802 struct cmd *parsecmd(char*);
7803 
7804 
7805 void
7806 runcmd(struct cmd *cmd)
7807 {
7808   int p[2];
7809   struct backcmd *bcmd;
7810   struct execcmd *ecmd;
7811   struct listcmd *lcmd;
7812   struct pipecmd *pcmd;
7813   struct redircmd *rcmd;
7814 
7815   if(cmd == 0)
7816     exit();
7817 
7818   switch(cmd->type){
7819   default:
7820     panic("runcmd");
7821 
7822   case EXEC:
7823     ecmd = (struct execcmd*)cmd;
7824     if(ecmd->argv[0] == 0)
7825       exit();
7826     exec(ecmd->argv[0], ecmd->argv);
7827     printf(2, "exec %s failed\n", ecmd->argv[0]);
7828     break;
7829 
7830   case REDIR:
7831     rcmd = (struct redircmd*)cmd;
7832     close(rcmd->fd);
7833     if(open(rcmd->file, rcmd->mode) < 0){
7834       printf(2, "open %s failed\n", rcmd->file);
7835       exit();
7836     }
7837     runcmd(rcmd->cmd);
7838     break;
7839 
7840   case LIST:
7841     lcmd = (struct listcmd*)cmd;
7842     if(fork1() == 0)
7843       runcmd(lcmd->left);
7844     wait();
7845     runcmd(lcmd->right);
7846     break;
7847 
7848 
7849 
7850   case PIPE:
7851     pcmd = (struct pipecmd*)cmd;
7852     if(pipe(p) < 0)
7853       panic("pipe");
7854     if(fork1() == 0){
7855       close(1);
7856       dup(p[1]);
7857       close(p[0]);
7858       close(p[1]);
7859       runcmd(pcmd->left);
7860     }
7861     if(fork1() == 0){
7862       close(0);
7863       dup(p[0]);
7864       close(p[0]);
7865       close(p[1]);
7866       runcmd(pcmd->right);
7867     }
7868     close(p[0]);
7869     close(p[1]);
7870     wait();
7871     wait();
7872     break;
7873 
7874   case BACK:
7875     bcmd = (struct backcmd*)cmd;
7876     if(fork1() == 0)
7877       runcmd(bcmd->cmd);
7878     break;
7879   }
7880   exit();
7881 }
7882 
7883 int
7884 getcmd(char *buf, int nbuf)
7885 {
7886   printf(2, "$ ");
7887   memset(buf, 0, nbuf);
7888   gets(buf, nbuf);
7889   if(buf[0] == 0) 
7890     return -1;
7891   return 0;
7892 }
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 int
7901 main(void)
7902 {
7903   static char buf[100];
7904   int fd;
7905 
7906   
7907   while((fd = open("console", O_RDWR)) >= 0){
7908     if(fd >= 3){
7909       close(fd);
7910       break;
7911     }
7912   }
7913 
7914   
7915   while(getcmd(buf, sizeof(buf)) >= 0){
7916     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
7917       
7918       buf[strlen(buf)-1] = 0;  
7919       if(chdir(buf+3) < 0)
7920         printf(2, "cannot cd %s\n", buf+3);
7921       continue;
7922     }
7923     if(fork1() == 0)
7924       runcmd(parsecmd(buf));
7925     wait();
7926   }
7927   exit();
7928 }
7929 
7930 void
7931 panic(char *s)
7932 {
7933   printf(2, "%s\n", s);
7934   exit();
7935 }
7936 
7937 int
7938 fork1(void)
7939 {
7940   int pid;
7941 
7942   pid = fork();
7943   if(pid == -1)
7944     panic("fork");
7945   return pid;
7946 }
7947 
7948 
7949 
7950 
7951 
7952 struct cmd*
7953 execcmd(void)
7954 {
7955   struct execcmd *cmd;
7956 
7957   cmd = malloc(sizeof(*cmd));
7958   memset(cmd, 0, sizeof(*cmd));
7959   cmd->type = EXEC;
7960   return (struct cmd*)cmd;
7961 }
7962 
7963 struct cmd*
7964 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
7965 {
7966   struct redircmd *cmd;
7967 
7968   cmd = malloc(sizeof(*cmd));
7969   memset(cmd, 0, sizeof(*cmd));
7970   cmd->type = REDIR;
7971   cmd->cmd = subcmd;
7972   cmd->file = file;
7973   cmd->efile = efile;
7974   cmd->mode = mode;
7975   cmd->fd = fd;
7976   return (struct cmd*)cmd;
7977 }
7978 
7979 struct cmd*
7980 pipecmd(struct cmd *left, struct cmd *right)
7981 {
7982   struct pipecmd *cmd;
7983 
7984   cmd = malloc(sizeof(*cmd));
7985   memset(cmd, 0, sizeof(*cmd));
7986   cmd->type = PIPE;
7987   cmd->left = left;
7988   cmd->right = right;
7989   return (struct cmd*)cmd;
7990 }
7991 
7992 
7993 
7994 
7995 
7996 
7997 
7998 
7999 
8000 struct cmd*
8001 listcmd(struct cmd *left, struct cmd *right)
8002 {
8003   struct listcmd *cmd;
8004 
8005   cmd = malloc(sizeof(*cmd));
8006   memset(cmd, 0, sizeof(*cmd));
8007   cmd->type = LIST;
8008   cmd->left = left;
8009   cmd->right = right;
8010   return (struct cmd*)cmd;
8011 }
8012 
8013 struct cmd*
8014 backcmd(struct cmd *subcmd)
8015 {
8016   struct backcmd *cmd;
8017 
8018   cmd = malloc(sizeof(*cmd));
8019   memset(cmd, 0, sizeof(*cmd));
8020   cmd->type = BACK;
8021   cmd->cmd = subcmd;
8022   return (struct cmd*)cmd;
8023 }
8024 
8025 
8026 char whitespace[] = " \t\r\n\v";
8027 char symbols[] = "<|>&;()";
8028 
8029 int
8030 gettoken(char **ps, char *es, char **q, char **eq)
8031 {
8032   char *s;
8033   int ret;
8034 
8035   s = *ps;
8036   while(s < es && strchr(whitespace, *s))
8037     s++;
8038   if(q)
8039     *q = s;
8040   ret = *s;
8041   switch(*s){
8042   case 0:
8043     break;
8044   case '|':
8045   case '(':
8046   case ')':
8047   case ';':
8048   case '&':
8049   case '<':
8050     s++;
8051     break;
8052   case '>':
8053     s++;
8054     if(*s == '>'){
8055       ret = '+';
8056       s++;
8057     }
8058     break;
8059   default:
8060     ret = 'a';
8061     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8062       s++;
8063     break;
8064   }
8065   if(eq)
8066     *eq = s;
8067 
8068   while(s < es && strchr(whitespace, *s))
8069     s++;
8070   *ps = s;
8071   return ret;
8072 }
8073 
8074 int
8075 peek(char **ps, char *es, char *toks)
8076 {
8077   char *s;
8078 
8079   s = *ps;
8080   while(s < es && strchr(whitespace, *s))
8081     s++;
8082   *ps = s;
8083   return *s && strchr(toks, *s);
8084 }
8085 
8086 
8087 
8088 
8089 
8090 
8091 
8092 
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 struct cmd *parseline(char**, char*);
8101 struct cmd *parsepipe(char**, char*);
8102 struct cmd *parseexec(char**, char*);
8103 struct cmd *nulterminate(struct cmd*);
8104 
8105 struct cmd*
8106 parsecmd(char *s)
8107 {
8108   char *es;
8109   struct cmd *cmd;
8110 
8111   es = s + strlen(s);
8112   cmd = parseline(&s, es);
8113   peek(&s, es, "");
8114   if(s != es){
8115     printf(2, "leftovers: %s\n", s);
8116     panic("syntax");
8117   }
8118   nulterminate(cmd);
8119   return cmd;
8120 }
8121 
8122 struct cmd*
8123 parseline(char **ps, char *es)
8124 {
8125   struct cmd *cmd;
8126 
8127   cmd = parsepipe(ps, es);
8128   while(peek(ps, es, "&")){
8129     gettoken(ps, es, 0, 0);
8130     cmd = backcmd(cmd);
8131   }
8132   if(peek(ps, es, ";")){
8133     gettoken(ps, es, 0, 0);
8134     cmd = listcmd(cmd, parseline(ps, es));
8135   }
8136   return cmd;
8137 }
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 struct cmd*
8151 parsepipe(char **ps, char *es)
8152 {
8153   struct cmd *cmd;
8154 
8155   cmd = parseexec(ps, es);
8156   if(peek(ps, es, "|")){
8157     gettoken(ps, es, 0, 0);
8158     cmd = pipecmd(cmd, parsepipe(ps, es));
8159   }
8160   return cmd;
8161 }
8162 
8163 struct cmd*
8164 parseredirs(struct cmd *cmd, char **ps, char *es)
8165 {
8166   int tok;
8167   char *q, *eq;
8168 
8169   while(peek(ps, es, "<>")){
8170     tok = gettoken(ps, es, 0, 0);
8171     if(gettoken(ps, es, &q, &eq) != 'a')
8172       panic("missing file for redirection");
8173     switch(tok){
8174     case '<':
8175       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8176       break;
8177     case '>':
8178       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8179       break;
8180     case '+':  
8181       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8182       break;
8183     }
8184   }
8185   return cmd;
8186 }
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 struct cmd*
8201 parseblock(char **ps, char *es)
8202 {
8203   struct cmd *cmd;
8204 
8205   if(!peek(ps, es, "("))
8206     panic("parseblock");
8207   gettoken(ps, es, 0, 0);
8208   cmd = parseline(ps, es);
8209   if(!peek(ps, es, ")"))
8210     panic("syntax - missing )");
8211   gettoken(ps, es, 0, 0);
8212   cmd = parseredirs(cmd, ps, es);
8213   return cmd;
8214 }
8215 
8216 struct cmd*
8217 parseexec(char **ps, char *es)
8218 {
8219   char *q, *eq;
8220   int tok, argc;
8221   struct execcmd *cmd;
8222   struct cmd *ret;
8223 
8224   if(peek(ps, es, "("))
8225     return parseblock(ps, es);
8226 
8227   ret = execcmd();
8228   cmd = (struct execcmd*)ret;
8229 
8230   argc = 0;
8231   ret = parseredirs(ret, ps, es);
8232   while(!peek(ps, es, "|)&;")){
8233     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8234       break;
8235     if(tok != 'a')
8236       panic("syntax");
8237     cmd->argv[argc] = q;
8238     cmd->eargv[argc] = eq;
8239     argc++;
8240     if(argc >= MAXARGS)
8241       panic("too many args");
8242     ret = parseredirs(ret, ps, es);
8243   }
8244   cmd->argv[argc] = 0;
8245   cmd->eargv[argc] = 0;
8246   return ret;
8247 }
8248 
8249 
8250 
8251 struct cmd*
8252 nulterminate(struct cmd *cmd)
8253 {
8254   int i;
8255   struct backcmd *bcmd;
8256   struct execcmd *ecmd;
8257   struct listcmd *lcmd;
8258   struct pipecmd *pcmd;
8259   struct redircmd *rcmd;
8260 
8261   if(cmd == 0)
8262     return 0;
8263 
8264   switch(cmd->type){
8265   case EXEC:
8266     ecmd = (struct execcmd*)cmd;
8267     for(i=0; ecmd->argv[i]; i++)
8268       *ecmd->eargv[i] = 0;
8269     break;
8270 
8271   case REDIR:
8272     rcmd = (struct redircmd*)cmd;
8273     nulterminate(rcmd->cmd);
8274     *rcmd->efile = 0;
8275     break;
8276 
8277   case PIPE:
8278     pcmd = (struct pipecmd*)cmd;
8279     nulterminate(pcmd->left);
8280     nulterminate(pcmd->right);
8281     break;
8282 
8283   case LIST:
8284     lcmd = (struct listcmd*)cmd;
8285     nulterminate(lcmd->left);
8286     nulterminate(lcmd->right);
8287     break;
8288 
8289   case BACK:
8290     bcmd = (struct backcmd*)cmd;
8291     nulterminate(bcmd->cmd);
8292     break;
8293   }
8294   return cmd;
8295 }
8296 
8297 
8298 
8299 
8300 
8301 
8302 
8303 
8304 
8305 
8306 
8307 
8308 
8309 .code16                       
8310 .globl start
8311 start:
8312   cli                         
8313 
8314   
8315   xorw    %ax,%ax             
8316   movw    %ax,%ds             
8317   movw    %ax,%es             
8318   movw    %ax,%ss             
8319 
8320   
8321   
8322 seta20.1:
8323   inb     $0x64,%al               
8324   testb   $0x2,%al
8325   jnz     seta20.1
8326 
8327   movb    $0xd1,%al               
8328   outb    %al,$0x64
8329 
8330 seta20.2:
8331   inb     $0x64,%al               
8332   testb   $0x2,%al
8333   jnz     seta20.2
8334 
8335   movb    $0xdf,%al               
8336   outb    %al,$0x60
8337 
8338   
8339   
8340   
8341   lgdt    gdtdesc
8342   movl    %cr0, %eax
8343   orl     $CR0_PE, %eax
8344   movl    %eax, %cr0
8345 
8346   
8347   
8348   
8349   ljmp    $(SEG_KCODE<<3), $start32
8350 .code32  
8351 start32:
8352   
8353   movw    $(SEG_KDATA<<3), %ax    
8354   movw    %ax, %ds                
8355   movw    %ax, %es                
8356   movw    %ax, %ss                
8357   movw    $0, %ax                 
8358   movw    %ax, %fs                
8359   movw    %ax, %gs                
8360 
8361   
8362   movl    $start, %esp
8363   call    bootmain
8364 
8365   
8366   
8367   movw    $0x8a00, %ax            
8368   movw    %ax, %dx
8369   outw    %ax, %dx
8370   movw    $0x8ae0, %ax            
8371   outw    %ax, %dx
8372 spin:
8373   jmp     spin
8374 
8375 
8376 .p2align 2                                
8377 gdt:
8378   SEG_NULLASM                             
8379   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
8380   SEG_ASM(STA_W, 0x0, 0xffffffff)         
8381 
8382 gdtdesc:
8383   .word   (gdtdesc - gdt - 1)             
8384   .long   gdt                             
8385 
8386 
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 
8401 
8402 
8403 
8404 
8405 
8406 
8407 #include "types.h"
8408 #include "elf.h"
8409 #include "x86.h"
8410 #include "memlayout.h"
8411 
8412 #define SECTSIZE  512
8413 
8414 void readseg(uchar*, uint, uint);
8415 
8416 void
8417 bootmain(void)
8418 {
8419   struct elfhdr *elf;
8420   struct proghdr *ph, *eph;
8421   void (*entry)(void);
8422   uchar* pa;
8423 
8424   elf = (struct elfhdr*)0x10000;  
8425 
8426   
8427   readseg((uchar*)elf, 4096, 0);
8428 
8429   
8430   if(elf->magic != ELF_MAGIC)
8431     return;  
8432 
8433   
8434   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
8435   eph = ph + elf->phnum;
8436   for(; ph < eph; ph++){
8437     pa = (uchar*)ph->paddr;
8438     readseg(pa, ph->filesz, ph->off);
8439     if(ph->memsz > ph->filesz)
8440       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
8441   }
8442 
8443   
8444   
8445   entry = (void(*)(void))(elf->entry);
8446   entry();
8447 }
8448 
8449 
8450 void
8451 waitdisk(void)
8452 {
8453   
8454   while((inb(0x1F7) & 0xC0) != 0x40)
8455     ;
8456 }
8457 
8458 
8459 void
8460 readsect(void *dst, uint offset)
8461 {
8462   
8463   waitdisk();
8464   outb(0x1F2, 1);   
8465   outb(0x1F3, offset);
8466   outb(0x1F4, offset >> 8);
8467   outb(0x1F5, offset >> 16);
8468   outb(0x1F6, (offset >> 24) | 0xE0);
8469   outb(0x1F7, 0x20);  
8470 
8471   
8472   waitdisk();
8473   insl(0x1F0, dst, SECTSIZE/4);
8474 }
8475 
8476 
8477 
8478 void
8479 readseg(uchar* pa, uint count, uint offset)
8480 {
8481   uchar* epa;
8482 
8483   epa = pa + count;
8484 
8485   
8486   pa -= offset % SECTSIZE;
8487 
8488   
8489   offset = (offset / SECTSIZE) + 1;
8490 
8491   
8492   
8493   
8494   for(; pa < epa; pa += SECTSIZE, offset++)
8495     readsect(pa, offset);
8496 }
8497 
8498 
8499 
8500 /* Simple linker script for the JOS kernel.
8501    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
8502 
8503 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
8504 OUTPUT_ARCH(i386)
8505 ENTRY(_start)
8506 
8507 SECTIONS
8508 {
8509 	/* Link the kernel at this address: "." means the current address */
8510         /* Must be equal to KERNLINK */
8511 	. = 0x80100000;
8512 
8513 	.text : AT(0x100000) {
8514 		*(.text .stub .text.* .gnu.linkonce.t.*)
8515 	}
8516 
8517 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
8518 
8519 	.rodata : {
8520 		*(.rodata .rodata.* .gnu.linkonce.r.*)
8521 	}
8522 
8523 	/* Include debugging information in kernel memory */
8524 	.stab : {
8525 		PROVIDE(__STAB_BEGIN__ = .);
8526 		*(.stab);
8527 		PROVIDE(__STAB_END__ = .);
8528 	}
8529 
8530 	.stabstr : {
8531 		PROVIDE(__STABSTR_BEGIN__ = .);
8532 		*(.stabstr);
8533 		PROVIDE(__STABSTR_END__ = .);
8534 	}
8535 
8536 	/* Adjust the address for the data segment to the next page */
8537 	. = ALIGN(0x1000);
8538 
8539 	/* Conventionally, Unix linkers provide pseudo-symbols
8540 	 * etext, edata, and end, at the end of the text, data, and bss.
8541 	 * For the kernel mapping, we need the address at the beginning
8542 	 * of the data section, but that's not one of the conventional
8543 	 * symbols, because the convention started before there was a
8544 	 * read-only rodata section between text and data. */
8545 	PROVIDE(data = .);
8546 
8547 
8548 
8549 
8550 	/* The data segment */
8551 	.data : {
8552 		*(.data)
8553 	}
8554 
8555 	PROVIDE(edata = .);
8556 
8557 	.bss : {
8558 		*(.bss)
8559 	}
8560 
8561 	PROVIDE(end = .);
8562 
8563 	/DISCARD/ : {
8564 		*(.eh_frame .note.GNU-stack)
8565 	}
8566 }
8567 
8568 
8569 
8570 
8571 
8572 
8573 
8574 
8575 
8576 
8577 
8578 
8579 
8580 
8581 
8582 
8583 
8584 
8585 
8586 
8587 
8588 
8589 
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
